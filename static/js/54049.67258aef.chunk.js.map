{"version":3,"file":"static/js/54049.67258aef.chunk.js","mappings":"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","sources":["../node_modules/@esri/hub-components/dist/esm/HubGroups-2b55773b.js","../node_modules/@esri/hub-components/dist/esm/fetch-a8e38b36.js","../node_modules/@esri/hub-components/dist/esm/get-859a2960.js","../node_modules/@esri/hub-components/dist/esm/request-f9ca03b5.js","../node_modules/@esri/hub-components/dist/esm/search-users-5cfad933.js","../node_modules/@esri/hub-components/dist/esm/utils-b3c19803.js"],"sourcesContent":["import { H as HubError } from './getPropertyMap-598a7bb8.js';\nimport { u as unique, c as cloneObject } from './util-3c40fe6c.js';\nimport { v as valueToMatchOptions, r as relativeDateToDateRange, b as getNextFunction, a as getUserThumbnailUrl, e as expandApi, g as getGroupThumbnailUrl } from './utils-b3c19803.js';\nimport { g as getProp } from './get-prop-d82e4fa6.js';\nimport { s as setProp } from './set-prop-91329c47.js';\nimport { g as getFamily, m as getHubRelativeUrl } from './_internal-89d3dc92.js';\nimport { f as fetchItemEnrichments, O as OperationStack, c as createOperationPipeline, g as getEnrichmentErrors, a as fetchOrg } from './_enrichments-7716cdcc.js';\nimport { p as parseInclude, e as enrichSiteSearchResult } from './HubSites-95889869.js';\nimport { m as mapBy } from './SiteBusinessRules-05d0a02f.js';\nimport { a as getItemThumbnailUrl } from './get-item-thumbnail-url-7e5ae2fd.js';\nimport { g as getItemHomeUrl } from './get-item-home-url-9ff2898b.js';\nimport { s as searchItems } from './search-3af9e278.js';\nimport { e as enrichProjectSearchResult } from './fetch-a8e38b36.js';\nimport { s as searchUsers } from './search-users-5cfad933.js';\nimport { g as getPortalBaseFromOrgUrl } from './getPortalBaseFromOrgUrl-6a5781aa.js';\nimport { a as getPortalUrl } from './get-portal-api-url-ccd8fd10.js';\nimport { R as RemoteServerError } from './request-f9ca03b5.js';\nimport { g as genericSearch } from './generic-search-069e22da.js';\nimport { s as searchGroupUsers } from './get-859a2960.js';\n\n/* Copyright (c) 2018-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n/**\n * ```js\n * import { searchGroups } from \"@esri/arcgis-rest-portal\";\n * //\n * searchGroups('water')\n *   .then(response) // response.total => 355\n * ```\n * Search a portal for groups. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/group-search.htm) for more information.\n *\n * @param search - A string or RequestOptions object to pass through to the endpoint.\n * @returns A Promise that will resolve with the data from the response.\n */\nfunction searchGroups(search) {\n    return genericSearch(search, \"group\");\n}\n/**\n * ```js\n * import { searchGroupContent } from \"@esri/arcgis-rest-portal\";\n * //\n * searchGroupContent('water')\n *   .then(response) // response.total => 355\n * ```\n * Search a portal for items in a group. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/group-content-search.htm) for more information.\n *\n * @param options - RequestOptions object amended with search parameters.\n * @returns A Promise that will resolve with the data from the response.\n */\nfunction searchGroupContent(options) {\n    return genericSearch(options, \"groupContent\");\n}\n\n/**\n * Return the URL of the group's page in the Portal Home application\n * @param groupId The group's ID\n * @param portalUrlOrObject a portal base or API URL, a portal object, or request options containing either of those\n * @returns URL to the groups's url, defaults to `https://www.arcgis.com/home/group.html?id={group.id}`\n */\nfunction getGroupHomeUrl(groupId, portalUrlOrObject) {\n    const portalUrl = getPortalUrl(portalUrlOrObject);\n    return `${portalUrl}/home/group.html?id=${groupId}`;\n}\n\n/**\n * Return the URL of the user's page in the Portal Home application\n * @param username The username\n * @param portalUrlOrObject a portal base or API URL, a portal object, or request options containing either of those\n * @returns URL to the user's profile, defaults to `https://www.arcgis.com/home/user.html?user={username}`\n */\nfunction getUserHomeUrl(username, portalUrlOrObject) {\n    const portalUrl = getPortalUrl(portalUrlOrObject);\n    return `${portalUrl}/home/user.html?user=${username}`;\n}\n\n/**\n * Enrich a generic search result\n * @param item\n * @param includes\n * @param requestOptions\n * @returns\n */\nasync function enrichContentSearchResult(item, include, requestOptions) {\n    // Create the basic structure\n    const result = {\n        access: item.access,\n        id: item.id,\n        type: item.type,\n        name: item.title,\n        owner: item.owner,\n        tags: item.tags,\n        typeKeywords: item.typeKeywords,\n        categories: item.categories,\n        summary: item.snippet || item.description,\n        createdDate: new Date(item.created),\n        createdDateSource: \"item.created\",\n        updatedDate: new Date(item.modified),\n        updatedDateSource: \"item.modified\",\n        family: getFamily(item.type),\n        links: {\n            self: \"not-implemented\",\n            siteRelative: \"not-implemented\",\n            thumbnail: \"not-implemented\",\n        },\n    };\n    // default includes\n    const DEFAULTS = [];\n    // Add any type-specific defaults here\n    // if ([\"Map Service\", \"Feature Service\"].includes(item.type)) {\n    //   DEFAULTS = [\"server.layers.length AS layerCount\"];\n    // }\n    // if (item.type === \"Web Map\") {\n    //   DEFAULTS = [\"data.operationalLayers.length AS layerCount\"];\n    // }\n    // merge includes\n    include = [...DEFAULTS, ...include].filter(unique);\n    // Parse the includes into a valid set of enrichments\n    const specs = include.map(parseInclude);\n    // Extract out the low-level enrichments needed\n    const enrichments = mapBy(\"enrichment\", specs).filter(unique);\n    // fetch the enrichments\n    let enriched = {};\n    if (enrichments.length) {\n        enriched = await fetchItemEnrichments(item, enrichments, requestOptions);\n    }\n    // map the enriched props onto the result\n    specs.forEach((spec) => {\n        result[spec.prop] = getProp(enriched, spec.path);\n    });\n    // Handle links\n    // TODO: Link handling should be an enrichment\n    result.links.thumbnail = getItemThumbnailUrl(item, requestOptions);\n    result.links.self = getItemHomeUrl(result.id, requestOptions);\n    result.links.siteRelative = getHubRelativeUrl(result.type, result.id, item.typeKeywords);\n    return result;\n}\n\n/**\n * Fetch the count of items shared to the group.\n * This is done by searching for content in the group\n * and using the returned `total` value\n * @param input\n * @returns\n */\nconst enrichGroupContentCount = (input) => {\n    const { data, stack, requestOptions } = input;\n    const opId = stack.start(\"enrichGroupContentCount\");\n    // w/o the : any here, I get a compile error about\n    // .authentication being incompatible w/ UserSession\n    const options = Object.assign({ groupId: data.group.id, num: 1 }, requestOptions);\n    return searchGroupContent(options)\n        .then((results) => {\n        stack.finish(opId);\n        return {\n            data: Object.assign(Object.assign({}, data), { contentCount: results.total }),\n            stack,\n            requestOptions,\n        };\n    })\n        .catch((error) => handleEnrichmentError$1(error, input, opId));\n};\n/**\n * Create a summary of the Group membership by searching for members,\n * limiting to three for a sample, and using the `total`.\n * @param input\n * @returns\n */\nconst enrichGroupMembershipSummary = (input) => {\n    const { data, stack, requestOptions } = input;\n    const opId = stack.start(\"enrichGroupContentCount\");\n    // w/o the `: any` here, I get a compile error about\n    // .authentication being incompatible w/ UserSession\n    const options = Object.assign({ num: 3 }, requestOptions);\n    return searchGroupUsers(data.group.id, options)\n        .then((results) => {\n        stack.finish(opId);\n        return {\n            data: Object.assign(Object.assign({}, data), {\n                membershipSummary: { total: results.total, users: results.users },\n            }),\n            stack,\n            requestOptions,\n        };\n    })\n        .catch((error) => handleEnrichmentError$1(error, input, opId));\n};\n// add the error to the content.errors,\n// log current stack operation as finished with an error\n// and return output that can be piped into the next operation\nconst handleEnrichmentError$1 = (error, input, opId) => {\n    const { data, stack, requestOptions } = input;\n    stack.finish(opId, { error });\n    return {\n        data: Object.assign(Object.assign({}, data), { errors: getEnrichmentErrors(error, data.errors) }),\n        stack,\n        requestOptions,\n    };\n};\n/**\n * Available enrichments for Groups\n */\nconst groupEnrichementOperations$1 = {\n    membershipSummary: enrichGroupMembershipSummary,\n    contentCount: enrichGroupContentCount,\n};\n/**\n * Fetch enrichments for Groups\n * @param group\n * @param enrichments\n * @param requestOptions\n * @returns\n */\nfunction fetchGroupEnrichments(group, enrichments, requestOptions) {\n    // create a pipeline of enrichment operations\n    const operations = enrichments.reduce((ops, enrichment) => {\n        const operation = groupEnrichementOperations$1[enrichment];\n        // only include the enrichments that we know how to fetch\n        operation && ops.push(operation);\n        return ops;\n    }, []);\n    const pipeline = createOperationPipeline(operations);\n    // execute pipeline and return the item and enrichments\n    return pipeline({\n        data: { group },\n        stack: new OperationStack(),\n        requestOptions,\n    }).then((output) => {\n        // TODO: send telemetry so we have info on what enrichments are requested and possible errors\n        return output.data;\n    });\n}\n\n/**\n * @private\n * Expand a predicate\n * @param predicate\n * @returns\n */\nfunction expandPredicate(predicate) {\n    const result = {};\n    const dateProps = [\"created\", \"modified\", \"lastlogin\"];\n    const copyProps = [\n        \"filterType\",\n        \"categoriesAsParam\",\n        \"categoryFilter\",\n        \"term\",\n        \"searchUserAccess\",\n        \"isopendata\",\n        \"searchUserName\",\n    ];\n    const nonMatchOptionsFields = [...dateProps, ...copyProps];\n    // Do the conversion\n    Object.entries(predicate).forEach(([key, value]) => {\n        // Handle MatchOptions fields\n        if (!nonMatchOptionsFields.includes(key)) {\n            setProp(key, valueToMatchOptions(value), result);\n        }\n        // Handle Date fields\n        if (dateProps.includes(key)) {\n            const dateFieldValue = cloneObject(getProp(predicate, key));\n            if (getProp(predicate, `${key}.type`) === \"relative-date\") {\n                setProp(key, relativeDateToDateRange(dateFieldValue), result);\n            }\n            else {\n                setProp(key, dateFieldValue, result);\n            }\n        }\n        // Handle fields that are just copied forward\n        if (copyProps.includes(key) && predicate.hasOwnProperty(key)) {\n            setProp(key, value, result);\n        }\n    });\n    return result;\n}\n\n/**\n * Serialize IQuery into ISearchOptions for ArcGIS Portal\n * @param query\n * @returns\n */\nfunction serializeQueryForPortal(query) {\n    const filterSearchOptions = query.filters.map(serializeFilter);\n    // remove any empty entries\n    const nonEmptyOptions = filterSearchOptions.filter(removeEmptyEntries);\n    const result = mergeSearchOptions(nonEmptyOptions, \"AND\");\n    return result;\n}\n/**\n * Predicate to remove things from array\n * @param e\n * @returns\n */\nfunction removeEmptyEntries(e) {\n    return !(typeof e === \"undefined\" || e === null || e === \"\");\n}\nfunction mergeSearchOptions(options, operation) {\n    const result = options.reduce((acc, entry) => {\n        // walk the props\n        Object.entries(entry).forEach(([key, value]) => {\n            // if prop exists and is not empty string\n            if (acc[key] && value !== \"\") {\n                // combine via operation\n                acc[key] = `${acc[key]} ${operation} ${value}`;\n            }\n            else {\n                // just copy the value if it's not empty string\n                if (value !== \"\") {\n                    acc[key] = value;\n                }\n            }\n        });\n        return acc;\n    }, { q: \"\" });\n    return result;\n}\n/**\n * Serialize the filters in a FitlerGroup into a Portal Query\n * @param filter\n * @returns\n */\nfunction serializeFilter(filter) {\n    const operation = filter.operation || \"AND\";\n    const predicates = filter.predicates.map(expandPredicate);\n    const predicateSearchOptions = predicates\n        .map(serializePredicate)\n        .filter((e) => e !== undefined && e !== null);\n    // combine these searchOptions\n    const searchOptions = mergeSearchOptions(predicateSearchOptions, operation);\n    // wrap in parens if we have more than one predicate\n    if (predicates.length > 1) {\n        searchOptions.q = `(${searchOptions.q})`;\n    }\n    return searchOptions;\n}\n/**\n * Serialize a Filter into a Portal Query\n * @param predicate\n * @returns\n */\nfunction serializePredicate(predicate) {\n    const dateProps = [\"created\", \"modified\"];\n    const boolProps = [\"isopendata\"];\n    const passThroughProps = [\n        \"searchUserAccess\",\n        \"searchUserName\",\n        \"categoriesAsParam\",\n        \"categoryFilter\",\n    ];\n    const specialProps = [\n        \"filterType\",\n        \"term\",\n        ...dateProps,\n        ...boolProps,\n        ...passThroughProps,\n    ];\n    const portalAllowList = [\n        \"access\",\n        \"capabilities\",\n        \"created\",\n        \"categories\",\n        \"categoriesAsParam\",\n        \"categoryFilter\",\n        \"description\",\n        \"disabled\",\n        \"email\",\n        \"emailstatus\",\n        \"firstname\",\n        \"fullname\",\n        \"group\",\n        \"id\",\n        \"isInvitationOnly\",\n        \"isopendata\",\n        \"joined\",\n        \"lastlogin\",\n        \"lastname\",\n        \"memberType\",\n        \"modified\",\n        \"name\",\n        \"orgid\",\n        \"orgIds\",\n        \"owner\",\n        \"provider\",\n        \"role\",\n        \"searchUserAccess\",\n        \"searchUserName\",\n        \"snippet\",\n        \"tags\",\n        \"term\",\n        \"title\",\n        \"type\",\n        \"typekeywords\",\n        \"userlicensetype\",\n        \"username\",\n    ];\n    // TODO: Look at using reduce vs .map and remove the `.filter`\n    const opts = Object.entries(predicate)\n        .map(([key, value]) => {\n        // When serializing for portal we limit predicate properties to\n        // a list of known properties that the portal api accepts. This will\n        // not attempt to ensure the properties are used in the correct combinations\n        if (portalAllowList.includes(key)) {\n            const so = { q: \"\" };\n            if (!specialProps.includes(key) && key !== \"term\") {\n                so.q = serializeMatchOptions(key, value);\n            }\n            if (dateProps.includes(key)) {\n                so.q = serializeDateRange(key, value);\n            }\n            if (boolProps.includes(key)) {\n                so.q = `${key}:${value}`;\n            }\n            if (passThroughProps.includes(key)) {\n                so[key] = value;\n            }\n            if (key === \"term\") {\n                so.q = value;\n            }\n            return so;\n        }\n    })\n        .filter(removeEmptyEntries);\n    // merge up all the searchOptions\n    if (opts.length) {\n        const searchOptions = mergeSearchOptions(opts, \"AND\");\n        if (searchOptions.q) {\n            searchOptions.q = `(${searchOptions.q})`;\n        }\n        return searchOptions;\n    }\n    else {\n        return null;\n    }\n}\n/**\n * Serialize MatchOptions into portal syntax\n * @param key\n * @param value\n * @returns\n */\nfunction serializeMatchOptions(key, value) {\n    let result = \"\";\n    if (value.any) {\n        result = `${serializeStringOrArray(\"OR\", key, value.any)}`;\n    }\n    if (value.all) {\n        result =\n            (result ? result + \" AND \" : \"\") +\n                `${serializeStringOrArray(\"AND\", key, value.all)}`;\n    }\n    if (value.not) {\n        // negate the entries if they are not\n        result =\n            (result ? result + \" AND \" : \"\") +\n                `${serializeStringOrArray(\"OR\", `-${key}`, value.not)}`;\n    }\n    return result;\n}\n/**\n * Serialize a date-range into Portal syntax\n * @param key\n * @param range\n * @returns\n */\nfunction serializeDateRange(key, range) {\n    return `${key}:[${range.from} TO ${range.to}]`;\n}\n/**\n * Serialize a `string` or `string[]` into a string\n * @param join\n * @param key\n * @param value\n * @returns\n */\nfunction serializeStringOrArray(join, key, value) {\n    let q = \"\";\n    if (Array.isArray(value)) {\n        q = `${key}:\"${value.join(`\" ${join} ${key}:\"`)}\"`;\n        if (value.length > 1) {\n            q = `(${q})`;\n        }\n    }\n    else {\n        q = `${key}:\"${value}\"`;\n    }\n    return q;\n}\n\n/**\n * Fetch Page specific Enrichments\n * @param item\n * @param include\n * @param requestOptions\n * @returns\n */\nasync function enrichPageSearchResult(item, include, requestOptions) {\n    // Create the basic structure\n    const result = {\n        access: item.access,\n        id: item.id,\n        type: item.type,\n        name: item.title,\n        owner: item.owner,\n        typeKeywords: item.typeKeywords,\n        tags: item.tags,\n        categories: item.categories,\n        summary: item.snippet || item.description,\n        createdDate: new Date(item.created),\n        createdDateSource: \"item.created\",\n        updatedDate: new Date(item.modified),\n        updatedDateSource: \"item.modified\",\n        family: getFamily(item.type),\n        links: {\n            self: \"not-implemented\",\n            siteRelative: \"not-implemented\",\n            thumbnail: \"not-implemented\",\n        },\n    };\n    // default includes\n    const DEFAULTS = [];\n    // merge includes\n    include = [...DEFAULTS, ...include].filter(unique);\n    // Parse the includes into a valid set of enrichments\n    const specs = include.map(parseInclude);\n    // Extract out the low-level enrichments needed\n    const enrichments = mapBy(\"enrichment\", specs).filter(unique);\n    // fetch the enrichments\n    let enriched = {};\n    if (enrichments.length) {\n        // TODO: Look into caching for the requests in fetchItemEnrichments\n        enriched = await fetchItemEnrichments(item, enrichments, requestOptions);\n    }\n    // map the enriched props onto the result\n    specs.forEach((spec) => {\n        result[spec.prop] = getProp(enriched, spec.path);\n    });\n    // Handle Links\n    result.links.thumbnail = getItemThumbnailUrl(item, requestOptions);\n    result.links.self = getItemHomeUrl(result.id, requestOptions);\n    result.links.siteRelative = getHubRelativeUrl(result.type, result.id, item.typeKeywords);\n    return result;\n}\n\n/**\n * @private\n * Convert a portal aggregation structure into the HubAggregations structure\n * @param searchResults\n * @returns\n */\nfunction convertPortalAggregations(searchResults) {\n    var _a;\n    if ((_a = searchResults.aggregations) === null || _a === void 0 ? void 0 : _a.counts) {\n        return searchResults.aggregations.counts.map((entry) => {\n            return {\n                mode: \"terms\",\n                field: entry.fieldName,\n                values: entry.fieldValues,\n            };\n        });\n    }\n    else {\n        return [];\n    }\n}\n\n/**\n * @private\n * Portal Search Implementation for Items\n * @param query\n * @param options\n * @returns\n */\nasync function portalSearchItems(query, options) {\n    var _a;\n    if (!options.requestOptions) {\n        throw new HubError(\"portalSearchItems\", \"options.requestOptions is required.\");\n    }\n    // Expand well-known filterGroups\n    const updatedQuery = applyWellKnownItemPredicates(query);\n    // Expand the individual predicates in each filter\n    updatedQuery.filters = updatedQuery.filters.map((filter) => {\n        filter.predicates = filter.predicates.map(expandPredicate);\n        return filter;\n    });\n    // Serialize the all the groups for portal\n    const so = serializeQueryForPortal(updatedQuery);\n    // Array of properties we want to copy from IHubSearchOptions to the ISearchOptions\n    const props = [\n        \"num\",\n        \"sortField\",\n        \"sortOrder\",\n        \"include\",\n        \"start\",\n        \"requestOptions\",\n    ];\n    // copy the props over\n    props.forEach((prop) => {\n        if (options.hasOwnProperty(prop)) {\n            so[prop] = options[prop];\n        }\n    });\n    if (options.requestOptions.authentication) {\n        so.authentication = options.requestOptions.authentication;\n    }\n    else {\n        so.portal = options.requestOptions.portal;\n    }\n    // Aggregations\n    if ((_a = options.aggFields) === null || _a === void 0 ? void 0 : _a.length) {\n        so.countFields = options.aggFields.join(\",\");\n        so.countSize = options.aggLimit || 10;\n    }\n    return searchPortal$2(so);\n}\n/**\n * Internal portal search, which then converts `IItem`s to `IHubSearchResult`s\n * handling enrichments & includes along the way\n *\n * @param searchOptions\n * @returns\n */\nasync function searchPortal$2(searchOptions) {\n    // Execute portal search\n    const resp = await searchItems(searchOptions);\n    // create mappable fn that will handle the includes\n    const fn = (item) => {\n        return itemToSearchResult(item, searchOptions.includes, searchOptions.requestOptions);\n    };\n    // map over results\n    const results = await Promise.all(resp.results.map(fn));\n    // convert portal  aggregations into hub aggregations\n    const aggregations = convertPortalAggregations(resp);\n    // Construct the return\n    return {\n        total: resp.total,\n        results,\n        aggregations,\n        hasNext: resp.nextStart > -1,\n        next: getNextFunction(searchOptions, resp.nextStart, resp.total, searchPortal$2),\n    };\n}\n/**\n * Convert an `IItem` to a `IHubSearchResult`\n * Fetches the enrichments, and attaches them as directed in the `include` list\n * @param item\n * @param includes\n * @param requestOptions\n * @returns\n */\nasync function itemToSearchResult(item, includes = [], requestOptions) {\n    // based on the type, we delegate to type-specific functions\n    // this allows each type to apply \"default\" enrichments\n    let fn = enrichContentSearchResult;\n    switch (item.type) {\n        case \"Hub Site Application\":\n        case \"Site Application\":\n            fn = enrichSiteSearchResult;\n            break;\n        case \"Hub Page\":\n        case \"Site Page\":\n            fn = enrichPageSearchResult;\n            break;\n        case \"Hub Project\":\n            fn = enrichProjectSearchResult;\n            break;\n        // handle old hub sites\n        case \"Web Mapping Application\":\n            if (item.typeKeywords.includes(\"hubSite\")) {\n                fn = enrichSiteSearchResult;\n            }\n            break;\n    }\n    return fn(item, includes, requestOptions);\n}\nconst WellKnownItemPredicates = {\n    $application: [\n        {\n            type: {\n                any: [\n                    \"Web Mapping Application\",\n                    \"Application\",\n                    \"Insights\",\n                    \"Web Experience\",\n                ],\n                not: [\"Insights Theme\", \"Insights Model\"],\n            },\n            typekeywords: {\n                not: [\"hubSite\", \"Story Map\"],\n            },\n        },\n        {\n            type: \"Web Mapping Experience\",\n            typekeywords: \"EXB Experience\",\n        },\n    ],\n    $dashboard: [\n        {\n            type: {\n                any: [\"Dashboard\"],\n                not: [\"Operation View\"],\n            },\n            typekeywords: {\n                not: [\"Extension\", \"ArcGIS Operation View\"],\n            },\n        },\n    ],\n    $dataset: [\n        {\n            type: {\n                any: [\n                    \"Scene Service\",\n                    \"Feature Collection\",\n                    \"Route Layer\",\n                    \"Layer\",\n                    \"Explorer Layer\",\n                    \"Tile Package\",\n                    \"Vector Tile Package\",\n                    \"Scene Package\",\n                    \"Layer Package\",\n                    \"Feature Service\",\n                    \"Stream Service\",\n                    \"Map Service\",\n                    \"Vector Tile Service\",\n                    \"Image Service\",\n                    \"WMS\",\n                    \"WFS\",\n                    \"WMTS\",\n                    \"KML\",\n                    \"KML Collection\",\n                    \"Globe Service\",\n                    \"CSV\",\n                    \"Shapefile\",\n                    \"GeoJson\",\n                    \"Service Definition\",\n                    \"File Geodatabase\",\n                    \"CAD Drawing\",\n                    \"Relational Database Connection\",\n                ],\n                not: [\"Web Mapping Application\", \"Geodata Service\"],\n            },\n        },\n        {\n            typekeywords: [\"OGC\", \"Geodata Service\"],\n        },\n    ],\n    $document: [\n        {\n            type: [\n                \"PDF\",\n                \"Microsoft Excel\",\n                \"Microsoft Word\",\n                \"Microsoft Powerpoint\",\n                \"iWork Keynote\",\n                \"iWork Pages\",\n                \"iWork Numbers\",\n                \"Visio Document\",\n                \"Document Link\",\n            ],\n        },\n    ],\n    $initiative: [\n        {\n            type: \"Hub Initiative\",\n        },\n    ],\n    $experience: [\n        {\n            type: \"Web Experience\",\n        },\n    ],\n    $feedback: [\n        {\n            type: \"Form\",\n        },\n    ],\n    $page: [\n        {\n            typekeywords: \"hubPage\",\n        },\n    ],\n    $site: [\n        {\n            type: [\"Hub Site Application\", \"Site Application\"],\n        },\n    ],\n    $storymap: [\n        {\n            type: \"Storymap\",\n        },\n        {\n            type: \"Web Mapping Application\",\n            typekeywords: \"Story Map\",\n        },\n    ],\n    $template: [\n        {\n            type: [\n                \"Web Mapping Application\",\n                \"Hub Initiative\",\n                \"Hub Initiative Template\",\n                \"Solution\",\n            ],\n            typekeywords: {\n                any: [\"hubInitiativeTemplate\", \"hubSolutionTemplate\", \"Template\"],\n                not: \"Deployed\",\n            },\n        },\n    ],\n    $webmap: [\n        {\n            type: {\n                any: [\"Web Map\", \"Web Scene\"],\n                not: \"Web Mapping Application\",\n            },\n        },\n    ],\n};\n/**\n * @private\n * Convert a Filter Group to expand well-known type filters\n *\n * The purpose of this function is to allow for the use of short-hand\n * names for commonly used, complex queries.\n *\n * It works by looking for filters using the .type property, the value\n * of which is a key in the WellKnownItemFilters hash. If found in the\n * hash, the filters array of the active filterGroup is replaced with the\n * filters specified in the hash.\n *\n * NOTE: Any other properties specified in a filter will be removed\n *\n * Only exported to enable extensive testing\n * @param filterGroups\n */\nfunction applyWellKnownItemPredicates(query) {\n    const queryClone = cloneObject(query);\n    // iterate the filters\n    queryClone.filters = queryClone.filters.map((filter) => {\n        // replace predicates with well-known types\n        let replacedPredicates = false;\n        filter.predicates = filter.predicates.reduce((acc, predicate) => {\n            // if the predicate has a well-known type\n            // we replace it with the set of predicates defined\n            // for the well-known type\n            if (isWellKnownTypeFilter(predicate.type)) {\n                const replacements = lookupTypePredicates(predicate.type);\n                acc = [...acc, ...replacements];\n                replacedPredicates = true;\n            }\n            else {\n                // this predicate does not have a well-known type\n                // so we just keep it\n                acc.push(predicate);\n            }\n            return acc;\n        }, []);\n        if (replacedPredicates) {\n            // Any filter who's predicates were replaced with\n            // well-known predicates, needs to use \"OR\" to ensure\n            // correct query logic\n            filter.operation = \"OR\";\n        }\n        return filter;\n    });\n    return queryClone;\n}\n/**\n * Is the argument a well-known type \"key\"\n *\n * Accepts `string`, `string[]` or `IMatchOptions`\n * but only string values can possibly be keys\n * on `WellKnownItemFilters`\n * @param key\n * @returns\n */\nfunction isWellKnownTypeFilter(key) {\n    let result = false;\n    if (typeof key === \"string\") {\n        result = key in WellKnownItemPredicates;\n    }\n    return result;\n}\n/**\n * Return the predicates for a well-known type\n * @param key\n * @returns\n */\nfunction lookupTypePredicates(key) {\n    return WellKnownItemPredicates[key];\n}\n\nfunction formatOgcAggregationsResponse(response) {\n    const aggregations = response.aggregations.aggregations.map((ogcAgg) => ({\n        // What should it really be?\n        mode: \"terms\",\n        field: ogcAgg.field,\n        values: ogcAgg.aggregations.map((a) => ({\n            // Not confusing at all, right? Just some differences in terminology\n            value: a.label,\n            count: a.value,\n        })),\n    }));\n    return {\n        total: 0,\n        results: [],\n        hasNext: false,\n        next: () => null,\n        aggregations,\n    };\n}\n\nfunction getOgcAggregationQueryParams(_query, options) {\n    // TODO: use options.aggLimit once the OGC API supports it\n    const aggregations = `terms(fields=(${options.aggFields.join()}))`;\n    // TODO: Use `query` to filter aggregations once the OGC API supports it\n    const token = getProp(options, \"requestOptions.authentication.token\");\n    return { aggregations, token };\n}\n\nfunction getQueryString(queryParams) {\n    const result = Object.entries(queryParams)\n        .filter(([_key, value]) => !!value)\n        .map(([key, value]) => `${key}=${value}`)\n        .join(\"&\");\n    return result && `?${result}`;\n}\n\nasync function ogcApiRequest(url, queryParams, options) {\n    var _a;\n    // use fetch override if any\n    const _fetch = ((_a = options.requestOptions) === null || _a === void 0 ? void 0 : _a.fetch) || fetch;\n    const withQueryString = url + getQueryString(queryParams);\n    const response = await _fetch(withQueryString, { method: \"GET\" });\n    if (!response.ok) {\n        throw new RemoteServerError(response.statusText, withQueryString, response.status);\n    }\n    return response.json();\n}\n\nasync function searchOgcAggregations(query, options) {\n    const apiDefinition = options.api;\n    const url = `${apiDefinition.url}/aggregations`;\n    const queryParams = getOgcAggregationQueryParams(query, options);\n    const rawResponse = await ogcApiRequest(url, queryParams, options);\n    return formatOgcAggregationsResponse(rawResponse);\n}\n\nfunction getNextOgcCallback(response, originalQuery, originalOptions) {\n    const nextLink = response.links.find((l) => l.rel === \"next\");\n    let callback = () => null;\n    if (nextLink) {\n        callback = () => {\n            const nextUrl = new URL(nextLink.href);\n            const start = +nextUrl.searchParams.get(\"startindex\");\n            const nextOptions = Object.assign(Object.assign({}, originalOptions), { start });\n            return searchOgcItems(originalQuery, nextOptions);\n        };\n    }\n    return callback;\n}\n\nfunction ogcItemToSearchResult(ogcItem, includes, requestOptions) {\n    // OGC Api stuffs the item wholesale in  `.properties`\n    // NOTE: the properties hash may also have some extraneous members such\n    // as `license` and `source` if the OgcItem came from the index.\n    const pseudoItem = ogcItem.properties;\n    return itemToSearchResult(pseudoItem, includes, requestOptions);\n}\n\nasync function formatOgcItemsResponse(response, originalQuery, originalOptions) {\n    const formattedResults = await Promise.all(response.features.map((f) => ogcItemToSearchResult(f, originalOptions.include, originalOptions.requestOptions)));\n    const next = getNextOgcCallback(response, originalQuery, originalOptions);\n    const nextLink = response.links.find((l) => l.rel === \"next\");\n    return {\n        total: response.numberMatched,\n        results: formattedResults,\n        hasNext: !!nextLink,\n        next,\n    };\n}\n\nfunction getFilterQueryParam(query) {\n    return (query.filters\n        .map(formatFilterBlock)\n        // TODO: this a bandaid fix, remove once q can be passed into the filter query string\n        .filter((f) => f !== \"()\")\n        .join(\" AND \"));\n}\nfunction formatFilterBlock(filter) {\n    const operation = filter.operation || \"OR\";\n    const formatted = filter.predicates\n        .map(formatPredicate)\n        // TODO: this a bandaid fix, remove once q can be passed into the filter query string\n        .filter((p) => p !== \"()\")\n        .join(` ${operation} `);\n    return `(${formatted})`;\n}\nfunction formatPredicate(predicate) {\n    const formatted = Object.entries(predicate)\n        // Remove predicates that use `term` (handled in `getQQueryParam`) and undefined entries\n        .filter(([field, value]) => field !== \"term\" && !!value)\n        // Create sections for each field\n        .reduce((acc, [field, value]) => {\n        let section;\n        if (typeof value === \"string\") {\n            section = formatSimpleComparison(field, value);\n        }\n        else if (Array.isArray(value)) {\n            section = formatMultiStringPredicate(field, value);\n        }\n        else if (isDateRange(value)) {\n            section = formatDateRangePredicate(field, value);\n        }\n        else {\n            section = formatComplexPredicate(field, value);\n        }\n        acc.push(section);\n        return acc;\n    }, [])\n        // AND together all field requirements\n        .join(\" AND \");\n    return `(${formatted})`;\n}\nfunction isDateRange(x) {\n    return Number.isInteger(x.from) && Number.isInteger(x.to);\n}\nfunction formatDateRangePredicate(field, value) {\n    return `${field} BETWEEN ${value.from} AND ${value.to}`;\n}\nfunction formatSimpleComparison(field, value) {\n    return `${field}=${maybeAddSingleQuotes(value)}`;\n}\nfunction formatMultiStringPredicate(field, values) {\n    const wrappedValues = values.map(maybeAddSingleQuotes);\n    return `${field} IN (${wrappedValues.join(\", \")})`;\n}\nfunction formatComplexPredicate(field, value) {\n    const anys = formatAnys(field, value.any);\n    const alls = formatAlls(field, value.all);\n    const nots = formatNots(field, value.not);\n    return [anys, alls, nots].filter((subsection) => !!subsection).join(\" AND \");\n}\nfunction formatAnys(field, value) {\n    let result;\n    if (Array.isArray(value)) {\n        const wrappedValues = value.map(maybeAddSingleQuotes);\n        result = `${field} IN (${wrappedValues.join(\", \")})`;\n    }\n    else if (value) {\n        result = formatSimpleComparison(field, value);\n    }\n    return result;\n}\nfunction formatAlls(field, value) {\n    let result;\n    if (Array.isArray(value)) {\n        result = value\n            .map((v) => formatSimpleComparison(field, v))\n            .join(\" AND \");\n    }\n    else if (value) {\n        result = formatSimpleComparison(field, value);\n    }\n    return result;\n}\nfunction formatNots(field, value) {\n    let result;\n    if (value) {\n        const valueAsArray = Array.isArray(value) ? value : [value];\n        const wrappedValues = valueAsArray.map(maybeAddSingleQuotes);\n        result = `${field} NOT IN (${wrappedValues.join(\", \")})`;\n    }\n    return result;\n}\nfunction maybeAddSingleQuotes(value) {\n    const whitespaceRegex = /\\s/;\n    return whitespaceRegex.test(value) ? `'${value}'` : value;\n}\n\n// TODO: the 'q' query param logic is only here because the\n// OGC API currently has a bug where 'q' cannot be included\n// in the 'filter' string. Once that bug is resolved, rip this\n// logic out and let predicates with 'term' to be processed\n// normally\nfunction getQQueryParam(query) {\n    const qFilters = query.filters.filter((f) => {\n        return f.predicates.find((p) => !!p.term);\n    });\n    const qPredicate = getQPredicate(qFilters);\n    return qPredicate === null || qPredicate === void 0 ? void 0 : qPredicate.term;\n}\nfunction getQPredicate(filters) {\n    let result;\n    if (filters.length > 1) {\n        throw new Error(`IQuery can only have 1 IFilter with a 'term' predicate but ${filters.length} were detected`);\n    }\n    if (filters.length) {\n        const filter = filters[0];\n        const qPredicates = filter.predicates.filter((p) => !!p.term);\n        if (qPredicates.length > 1) {\n            throw new Error(`IQuery can only have 1 'term' predicate but ${qPredicates.length} were detected`);\n        }\n        if (filter.operation !== \"AND\" && filter.predicates.length > 1) {\n            throw new Error(`'term' predicates cannot be OR'd to other predicates`);\n        }\n        const qPredicate = qPredicates[0];\n        if (typeof qPredicate.term !== \"string\") {\n            throw new Error(`'term' predicate must have a string value, string[] and IMatchOptions are not allowed.`);\n        }\n        result = qPredicate;\n    }\n    return result;\n}\n\nfunction getOgcItemQueryParams(query, options) {\n    const filter = getFilterQueryParam(query);\n    const token = getProp(options, \"requestOptions.authentication.token\");\n    const limit = options.num;\n    // API requires the param name be all lowercase\n    const startindex = options.start;\n    const q = getQQueryParam(query);\n    return { filter, token, limit, startindex, q };\n}\n\nasync function searchOgcItems(query, options) {\n    const apiDefinition = options.api;\n    const url = `${apiDefinition.url}/items`;\n    const queryParams = getOgcItemQueryParams(query, options);\n    const rawResponse = await ogcApiRequest(url, queryParams, options);\n    return formatOgcItemsResponse(rawResponse, query, options);\n}\n\n/**\n * @private\n * Execute item search against the Hub API\n * @param query\n * @param options\n * @returns\n */\nasync function hubSearchItems(query, options) {\n    var _a;\n    if (!options.useBeta) {\n        throw new Error(\"Not implemented\");\n    }\n    return ((_a = options.aggFields) === null || _a === void 0 ? void 0 : _a.length) ? searchOgcAggregations(query, options)\n        : searchOgcItems(query, options);\n}\n\n/**\n * @private\n * Portal Search Implementation for Groups\n * @param query\n * @param options\n * @returns\n */\nasync function portalSearchGroups(query, options) {\n    if (!options.requestOptions) {\n        throw new HubError(\"portalSearchGroups\", \"options.requestOptions is required.\");\n    }\n    // Expand the individual predicates in each filter\n    query.filters = query.filters.map((filter) => {\n        filter.predicates = filter.predicates.map(expandPredicate);\n        return filter;\n    });\n    // Serialize the all the groups for portal\n    const so = serializeQueryForPortal(query);\n    // Array of properties we want to copy from IHubSearchOptions to the ISearchOptions\n    const props = [\n        \"num\",\n        \"sortField\",\n        \"sortOrder\",\n        \"include\",\n        \"start\",\n        \"requestOptions\",\n    ];\n    // copy the props over\n    props.forEach((prop) => {\n        if (options.hasOwnProperty(prop)) {\n            so[prop] = options[prop];\n        }\n    });\n    // If we don't have auth, ensure we have .portal\n    if (options.requestOptions.authentication) {\n        so.authentication = options.requestOptions.authentication;\n    }\n    else {\n        so.portal = options.requestOptions.portal;\n    }\n    return searchPortal$1(so);\n}\n/**\n * Internal portal search, which then converts `IGroup`s to `IHubSearchResult`s\n * handling enrichments & includes along the way\n *\n * @param searchOptions\n * @returns\n */\nasync function searchPortal$1(searchOptions) {\n    // Execute portal search\n    const resp = await searchGroups(searchOptions);\n    // create mappable fn that will close\n    // over the includes and requestOptions\n    const fn = (item) => {\n        return groupToSearchResult(item, searchOptions.include, searchOptions.requestOptions);\n    };\n    // map over results\n    const results = await Promise.all(resp.results.map(fn));\n    // Group Search does not support aggregations\n    // Construct the return\n    return {\n        total: resp.total,\n        results,\n        hasNext: resp.nextStart > -1,\n        next: getNextFunction(searchOptions, resp.nextStart, resp.total, searchPortal$1),\n    };\n}\n/**\n * Convert an Item to a IHubSearchResult\n * Fetches the includes and attaches them to the item\n * @param item\n * @param includes\n * @param requestOptions\n * @returns\n */\nasync function groupToSearchResult(group, includes = [], requestOptions) {\n    // Delegate to HubGroups module\n    // This layer of indirection is not necessary but\n    // aligns with how the items search works and\n    // allows for future specialization\n    return enrichGroupSearchResult(group, includes, requestOptions);\n}\n\nconst enrichUserOrg = (input) => {\n    const { data, stack, requestOptions } = input;\n    const opId = stack.start(\"enrichUserOrg\");\n    const options = Object.assign(Object.assign({}, requestOptions), { \n        // In order to get the correct response, we must pass options.portal\n        // as a base portal url (e.g., www.arcgis.com, qaext.arcgis.com, etc)\n        // **not** an org portal (i.e. org.maps.arcgis.com).\n        portal: `${getPortalBaseFromOrgUrl(requestOptions.portal)}/sharing/rest` });\n    // TODO: Add Caching\n    // Had implemented a simple caching system, but it leads to unstable\n    // tests because we can't deterministically clear it\n    // if (!orgCache[data.user.orgId]) {\n    //   orgCache[data.user.orgId] = fetchOrg(data.user.orgId, options);\n    // }\n    // return (orgCache[data.user.orgId] as Promise<IPortal>)\n    return fetchOrg(data.user.orgId, options)\n        .then((results) => {\n        stack.finish(opId);\n        return {\n            data: Object.assign(Object.assign({}, data), {\n                org: results,\n            }),\n            stack,\n            requestOptions,\n        };\n    })\n        .catch((error) => handleEnrichmentError(error, input, opId));\n};\n/**\n * Simple cache for user org's. This does not expire\n * but that seems reasonable as Org props rarely change\n */\n// This works find at run-time, but it's a problem in tests\n// where we are validating calls. Will work with Randy to\n// create something that's more robust\n// const orgCache: Record<string, any> = {};\n// add the error to the content.errors,\n// log current stack operation as finished with an error\n// and return output that can be piped into the next operation\nconst handleEnrichmentError = (error, input, opId) => {\n    const { data, stack, requestOptions } = input;\n    stack.finish(opId, { error });\n    return {\n        data: Object.assign(Object.assign({}, data), { errors: getEnrichmentErrors(error, data.errors) }),\n        stack,\n        requestOptions,\n    };\n};\n/**\n * Available enrichments for Groups\n */\nconst groupEnrichementOperations = {\n    org: enrichUserOrg,\n};\n/**\n * Fetch enrichments for Users\n * @param group\n * @param enrichments\n * @param requestOptions\n * @returns\n */\nfunction fetchUserEnrichments(user, enrichments, requestOptions) {\n    // create a pipeline of enrichment operations\n    const operations = enrichments.reduce((ops, enrichment) => {\n        const operation = groupEnrichementOperations[enrichment];\n        // only include the enrichments that we know how to fetch\n        operation && ops.push(operation);\n        return ops;\n    }, []);\n    const pipeline = createOperationPipeline(operations);\n    // execute pipeline and return the item and enrichments\n    return pipeline({\n        data: { user },\n        stack: new OperationStack(),\n        requestOptions,\n    }).then((output) => {\n        // TODO: send telemetry so we have info on what enrichments are requested and possible errors\n        return output.data;\n    });\n}\n\n/**\n * Enrich a User object\n * @param user\n * @param includes\n * @param requestOptions\n * @returns\n */\nasync function enrichUserSearchResult(user, include, requestOptions) {\n    // Create the basic structure\n    const result = {\n        access: user.access,\n        id: user.username,\n        type: \"User\",\n        name: user.fullName,\n        owner: user.username,\n        summary: user.description,\n        createdDate: new Date(user.created),\n        createdDateSource: \"user.created\",\n        updatedDate: new Date(user.modified),\n        updatedDateSource: \"user.modified\",\n        family: \"people\",\n        links: {\n            self: \"not-implemented\",\n            siteRelative: \"not-implemented\",\n            thumbnail: \"not-implemented\",\n        },\n    };\n    // Informal Enrichments - basically adding type-specific props\n    // derived directly from the entity\n    // default includes\n    const DEFAULTS = [\"org.name AS orgName\"];\n    // merge includes\n    include = [...DEFAULTS, ...include].filter(unique);\n    // Parse the includes into a valid set of enrichments\n    const specs = include.map(parseInclude);\n    // Extract out the low-level enrichments needed\n    const enrichments = mapBy(\"enrichment\", specs).filter(unique);\n    // fetch the enrichments\n    let enriched = {};\n    // Ignoring the else, because we currently have defaults, but want the guards\n    // so if we remove that in the future, we don't call the fn\n    /* istanbul ignore else */\n    if (enrichments.length) {\n        enriched = await fetchUserEnrichments(user, enrichments, requestOptions);\n    }\n    // map the enriched props onto the result\n    specs.forEach((spec) => {\n        result[spec.prop] = getProp(enriched, spec.path);\n    });\n    const token = requestOptions.authentication.token;\n    // Handle links\n    result.links.thumbnail = getUserThumbnailUrl(requestOptions.portal, user, token);\n    result.links.self = getUserHomeUrl(result.id, requestOptions);\n    result.links.siteRelative = `/people/${result.id}`;\n    return result;\n}\n\n/**\n * @private\n * Portal Search Implementation for Users\n * @param filterGroups\n * @param options\n * @returns\n */\nasync function portalSearchUsers(query, options) {\n    // requestOptions is always required and user must be authd\n    if (!options.requestOptions) {\n        throw new HubError(\"portalSearchUsers\", \"requestOptions: IHubRequestOptions is required.\");\n    }\n    if (!options.requestOptions.authentication) {\n        throw new HubError(\"portalSearchUsers\", \"requestOptions must pass authentication.\");\n    }\n    // Expand the individual predicates in each filter\n    query.filters = query.filters.map((filter) => {\n        filter.predicates = filter.predicates.map(expandPredicate);\n        return filter;\n    });\n    // Serialize the all the groups for portal\n    const so = serializeQueryForPortal(query);\n    // Array of properties we want to copy from IHubSearchOptions to the ISearchOptions\n    const props = [\n        \"num\",\n        \"sortField\",\n        \"sortOrder\",\n        \"include\",\n        \"start\",\n        \"requestOptions\",\n    ];\n    // copy the props over\n    props.forEach((prop) => {\n        if (options.hasOwnProperty(prop)) {\n            so[prop] = options[prop];\n        }\n    });\n    // Unlike Groups and Item, the Users api *requires* authentication\n    // so we set it directly\n    so.authentication = options.requestOptions.authentication;\n    // Execute search\n    return searchPortal(so);\n}\n/**\n * Internal portal search, which then converts `IGroup`s to `IHubSearchResult`s\n * handling enrichments & includes along the way\n *\n * @param searchOptions\n * @returns\n */\nasync function searchPortal(searchOptions) {\n    // Execute portal search\n    const resp = await searchUsers(searchOptions);\n    // create mappable fn that will close\n    // over the includes and requestOptions\n    const fn = (user) => {\n        return userToSearchResult(user, searchOptions.include, searchOptions.requestOptions);\n    };\n    // map over results\n    const results = await Promise.all(resp.results.map(fn));\n    // Group Search does not support aggregations\n    // Construct the return\n    return {\n        total: resp.total,\n        results,\n        hasNext: resp.nextStart > -1,\n        next: getNextFunction(searchOptions, resp.nextStart, resp.total, searchPortal),\n    };\n}\n/**\n * Convert an Item to a IHubSearchResult\n * Fetches the includes and attaches them to the item\n * @param item\n * @param include\n * @param requestOptions\n * @returns\n */\nasync function userToSearchResult(user, include = [], requestOptions) {\n    // Delegate to HubGroups module\n    // This layer of indirection is not necessary but\n    // aligns with how the items search works and\n    // allows for future specialization\n    return enrichUserSearchResult(user, include, requestOptions);\n}\n\n/**\n * Main entrypoint for searching via Hub\n *\n * Default's to search ArcGIS Portal but can delegate\n * to Hub API when it's available.\n * @param query\n * @param options\n * @returns\n */\nasync function hubSearch(query, options) {\n    // Validate inputs\n    if (!query) {\n        throw new HubError(\"hubSearch\", \"Query is required.\");\n    }\n    if (!query.filters || !query.filters.length) {\n        throw new HubError(\"hubSearch\", \"Query must contain at least one Filter.\");\n    }\n    if (!options.requestOptions) {\n        throw new HubError(\"hubSearch\", \"requestOptions: IHubRequestOptions is required.\");\n    }\n    // Ensure includes is an array\n    if (!options.include) {\n        options.include = [];\n    }\n    // Get the type of the first filterGroup\n    const filterType = query.targetEntity;\n    // get the API\n    const apiType = expandApi(options.api || \"arcgis\").type;\n    const fnHash = {\n        arcgis: {\n            item: portalSearchItems,\n            group: portalSearchGroups,\n            user: portalSearchUsers,\n        },\n        \"arcgis-hub\": {\n            item: hubSearchItems,\n        },\n    };\n    const fn = getProp(fnHash, `${apiType}.${filterType}`);\n    if (!fn) {\n        throw new HubError(`hubSearch`, `Search via \"${filterType}\" filter against \"${apiType}\" api is not implemented. Please ensure \"targetEntity\" is defined on the query.`);\n    }\n    return fn(cloneObject(query), options);\n}\n\n/**\n * Enrich a generic search result\n * @param group\n * @param includes\n * @param requestOptions\n * @returns\n */\nasync function enrichGroupSearchResult(group, include, requestOptions) {\n    // Create the basic structure\n    const result = {\n        access: group.access,\n        id: group.id,\n        type: \"Group\",\n        name: group.title,\n        owner: group.owner,\n        summary: group.snippet || group.description,\n        createdDate: new Date(group.created),\n        createdDateSource: \"group.created\",\n        updatedDate: new Date(group.modified),\n        updatedDateSource: \"group.modified\",\n        family: \"team\",\n        links: {\n            self: \"not-implemented\",\n            siteRelative: \"not-implemented\",\n            thumbnail: \"not-implemented\",\n        },\n    };\n    // Informal Enrichments - basically adding type-specific props\n    // derived directly from the entity\n    result.isSharedUpdate = (group.capabilities || []).includes(\"updateitemcontrol\");\n    result.membershipAccess = group.membershipAccess;\n    result.isOpenData = !!group.isOpenData;\n    // default includes\n    const DEFAULTS = [];\n    // merge includes\n    include = [...DEFAULTS, ...include].filter(unique);\n    // Parse the includes into a valid set of enrichments\n    const specs = include.map(parseInclude);\n    // Extract out the low-level enrichments needed\n    const enrichments = mapBy(\"enrichment\", specs).filter(unique);\n    // fetch the enrichments\n    let enriched = {};\n    if (enrichments.length) {\n        enriched = await fetchGroupEnrichments(group, enrichments, requestOptions);\n    }\n    // map the enriched props onto the result\n    specs.forEach((spec) => {\n        result[spec.prop] = getProp(enriched, spec.path);\n    });\n    // Handle links\n    result.links.thumbnail = getGroupThumbnailUrl(requestOptions.portal, group);\n    result.links.self = getGroupHomeUrl(result.id, requestOptions);\n    result.links.siteRelative = `/teams/${result.id}`;\n    return result;\n}\n\nexport { hubSearch as h };\n","import { g as getFamily, m as getHubRelativeUrl } from './_internal-89d3dc92.js';\nimport { k as computeProps, a as getItemBySlug, f as fetchModelFromItem, l as fetchModelResources, P as PropertyMapper, h as getPropertyMap, E as EntityResourceMap } from './getPropertyMap-598a7bb8.js';\nimport { f as fetchItemEnrichments } from './_enrichments-7716cdcc.js';\nimport { p as parseInclude } from './HubSites-95889869.js';\nimport { u as unique } from './util-3c40fe6c.js';\nimport { g as getProp } from './get-prop-d82e4fa6.js';\nimport { a as getItemThumbnailUrl } from './get-item-thumbnail-url-7e5ae2fd.js';\nimport { g as getItemHomeUrl } from './get-item-home-url-9ff2898b.js';\nimport { i as isGuid } from './is-guid-8127621d.js';\nimport { g as getItem } from './get-f2cd18e7.js';\nimport { m as mapBy } from './SiteBusinessRules-05d0a02f.js';\n\n/**\n * @private\n * Get a Hub Project by id or slug\n * @param identifier item id or slug\n * @param requestOptions\n */\nasync function fetchProject(identifier, requestOptions) {\n    let getPrms;\n    if (isGuid(identifier)) {\n        // get item by id\n        getPrms = getItem(identifier, requestOptions);\n    }\n    else {\n        getPrms = getItemBySlug(identifier, requestOptions);\n    }\n    return getPrms.then((item) => {\n        if (!item)\n            return null;\n        return convertItemToProject(item, requestOptions);\n    });\n}\n/**\n * @private\n * Convert an Hub Project Item into a Hub Project, fetching any additional\n * information that may be required\n * @param item\n * @param auth\n * @returns\n */\nasync function convertItemToProject(item, requestOptions) {\n    const model = await fetchModelFromItem(item, requestOptions);\n    // Fetch resources based on above obj\n    model.resources = await fetchModelResources(item, EntityResourceMap, requestOptions);\n    // TODO: In the future we will handle the boundary fetching from resource\n    const mapper = new PropertyMapper(getPropertyMap());\n    const prj = mapper.modelToObject(model, {});\n    return computeProps(model, prj, requestOptions);\n}\n/**\n * @private\n * Fetch project specific enrichments\n * @param item\n * @param include\n * @param requestOptions\n * @returns\n */\nasync function enrichProjectSearchResult(item, include, requestOptions) {\n    // Create the basic structure\n    const result = {\n        access: item.access,\n        id: item.id,\n        type: item.type,\n        name: item.title,\n        owner: item.owner,\n        typeKeywords: item.typeKeywords,\n        tags: item.tags,\n        categories: item.categories,\n        summary: item.snippet || item.description,\n        createdDate: new Date(item.created),\n        createdDateSource: \"item.created\",\n        updatedDate: new Date(item.modified),\n        updatedDateSource: \"item.modified\",\n        family: getFamily(item.type),\n        links: {\n            self: \"not-implemented\",\n            siteRelative: \"not-implemented\",\n            thumbnail: \"not-implemented\",\n        },\n    };\n    // default includes\n    const DEFAULTS = [];\n    // merge includes\n    include = [...DEFAULTS, ...include].filter(unique);\n    // Parse the includes into a valid set of enrichments\n    const specs = include.map(parseInclude);\n    // Extract out the low-level enrichments needed\n    const enrichments = mapBy(\"enrichment\", specs).filter(unique);\n    // fetch the enrichments\n    let enriched = {};\n    if (enrichments.length) {\n        // TODO: Look into caching for the requests in fetchItemEnrichments\n        enriched = await fetchItemEnrichments(item, enrichments, requestOptions);\n    }\n    // map the enriched props onto the result\n    specs.forEach((spec) => {\n        result[spec.prop] = getProp(enriched, spec.path);\n    });\n    // Handle links\n    // TODO: Link handling should be an enrichment\n    result.links.thumbnail = getItemThumbnailUrl(item, requestOptions);\n    result.links.self = getItemHomeUrl(result.id, requestOptions);\n    result.links.siteRelative = getHubRelativeUrl(result.type, result.id, item.typeKeywords);\n    return result;\n}\n\nexport { enrichProjectSearchResult as e, fetchProject as f };\n","import { _ as __assign } from './tslib.es6-3669ad41.js';\nimport { g as getPortalUrl } from './get-portal-url-423a76f5.js';\nimport { r as request } from './request-c15cc2af.js';\nimport { a as appendCustomParams } from './append-custom-params-fd9b7e72.js';\n\n/* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n/**\n * ```js\n * import { getGroup } from \"@esri/arcgis-rest-portal\";\n * //\n * getGroup(\"fxb988\") // id\n *   .then(response)\n * ```\n * Fetch a group using its id. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/group.htm) for more information.\n *\n * @param id - Group Id\n * @param requestOptions  - Options for the request\n * @returns  A Promise that will resolve with the data from the response.\n */\nfunction getGroup(id, requestOptions) {\n    var url = getPortalUrl(requestOptions) + \"/community/groups/\" + id;\n    // default to a GET request\n    var options = __assign({ httpMethod: \"GET\" }, requestOptions);\n    return request(url, options);\n}\n/**\n * Get the usernames of the admins and members. Does not return actual 'User' objects. Those must be\n * retrieved via separate calls to the User's API.\n * @param id - Group Id\n * @param requestOptions - Options for the request\n * @returns A Promise that will resolve with arrays of the group admin usernames and the member usernames\n */\nfunction getGroupUsers(id, requestOptions) {\n    var url = getPortalUrl(requestOptions) + \"/community/groups/\" + id + \"/users\";\n    // default to a GET request\n    var options = __assign({ httpMethod: \"GET\" }, requestOptions);\n    return request(url, options);\n}\n/**\n * ```js\n * import { searchGroupUsers } from \"@esri/arcgis-rest-portal\";\n * //\n * searchGroupUsers('abc123')\n *   .then(response)\n * ```\n * Search the users in a group. See the [REST Documentation](https://developers.arcgis.com/rest/users-groups-and-items/group-users-list.htm) for more information.\n *\n * @param id - The group id\n * @param searchOptions - Options for the request, including paging parameters.\n * @returns A Promise that will resolve with the data from the response.\n */\nfunction searchGroupUsers(id, searchOptions) {\n    var url = getPortalUrl(searchOptions) + \"/community/groups/\" + id + \"/userlist\";\n    var options = appendCustomParams(searchOptions || {}, [\"name\", \"num\", \"start\", \"sortField\", \"sortOrder\", \"joined\", \"memberType\"], {\n        httpMethod: \"GET\"\n    });\n    return request(url, options);\n}\n\nexport { getGroupUsers as a, getGroup as g, searchGroupUsers as s };\n","import { g as getHubApiUrl } from './api-196fe0e3.js';\n\n/**\n * @private\n */\nfunction buildUrl(params) {\n    const { host, path, query } = params;\n    const baseUrl = host.endsWith(\"/\") ? host : `${host}/`;\n    const url = new URL(path, baseUrl);\n    url.search = buildQueryString(query);\n    return url.toString();\n}\nfunction buildQueryString(params = {}) {\n    const queryParams = Object.keys(params)\n        .filter((key) => {\n        return params[key] !== undefined;\n    })\n        .reduce((acc, key) => {\n        acc[key] = params[key];\n        return acc;\n    }, {});\n    return new URLSearchParams(queryParams).toString();\n}\n\n/**\n * remote server error\n */\nclass RemoteServerError extends Error {\n    constructor(message, url, status) {\n        super(message);\n        this.status = status;\n        this.url = url;\n    }\n}\n/**\n * ```js\n * import { hubApiRequest } from \"@esri/hub-common\";\n * //\n * hubApiRequest(\n *   \"/datasets\",\n *   requestOptions\n * })\n *   .then(response);\n * ```\n * make a request to the Hub API\n * @param route API route\n * @param requestOptions request options\n */\nfunction hubApiRequest(route, requestOptions) {\n    // merge in default request options\n    const options = Object.assign({ \n        // why do we default to GET w/ our API?\n        httpMethod: \"GET\" }, requestOptions);\n    // use fetch override if any\n    const _fetch = options.fetch || fetch;\n    // merge in default headers\n    const headers = Object.assign({ \"Content-Type\": \"application/json\" }, options.headers);\n    // build query params/body based on requestOptions.params\n    let query;\n    let body;\n    if (options.httpMethod === \"GET\") {\n        // pass params in query string\n        query = options.params;\n    }\n    else {\n        // pass params in request body\n        body = JSON.stringify(options.params);\n    }\n    // build Hub API URL\n    const url = buildUrl({\n        host: getHubApiUrl(options),\n        path: `/api/v3/${route}`.replace(/\\/\\//g, \"/\"),\n        query,\n    });\n    return _fetch(url, {\n        method: options.httpMethod,\n        headers,\n        body,\n    }).then((resp) => {\n        if (resp.ok) {\n            return resp.json();\n        }\n        else {\n            throw new RemoteServerError(resp.statusText, url, resp.status);\n        }\n    });\n}\n\nexport { RemoteServerError as R, buildUrl as b, hubApiRequest as h };\n","import { g as genericSearch } from './generic-search-069e22da.js';\n\n/**\n * ```js\n * import { searchItems } from \"@esri/arcgis-rest-portal\";\n * //\n * searchUsers({ q: 'tommy', authentication })\n *   .then(response) // response.total => 355\n * ```\n * Search a portal for users.\n *\n * @param search - A RequestOptions object to pass through to the endpoint.\n * @returns A Promise that will resolve with the data from the response.\n */\nfunction searchUsers(search) {\n    return genericSearch(search, \"user\");\n}\n\nexport { searchUsers as s };\n","import { c as cloneObject } from './util-3c40fe6c.js';\nimport { U as UserSession } from './UserSession-d3a97494.js';\n\n/* Copyright (c) 2018-2021 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n/**\n * Well known APIs\n * Short-forms for specifying common APIs\n * We will likely deprecate this\n */\nconst SEARCH_APIS = {\n    arcgis: {\n        label: \"ArcGIS Online\",\n        url: \"https://www.arcgis.com\",\n        type: \"arcgis\",\n    },\n    arcgisQA: {\n        label: \"ArcGIS Online QAEXT\",\n        url: \"https://qaext.arcgis.com\",\n        type: \"arcgis\",\n    },\n    arcgisDEV: {\n        label: \"ArcGIS Online DEVEXT\",\n        url: \"https://devext.arcgis.com\",\n        type: \"arcgis\",\n    },\n    hub: {\n        label: \"ArcGIS Hub\",\n        url: \"https://hub.arcgis.com/api\",\n        type: \"arcgis-hub\",\n    },\n    hubDEV: {\n        label: \"ArcGIS Hub DEV\",\n        url: \"https://hubdev.arcgis.com/api\",\n        type: \"arcgis-hub\",\n    },\n    hubQA: {\n        label: \"ArcGIS Hub QA\",\n        url: \"https://hubqa.arcgis.com/api\",\n        type: \"arcgis-hub\",\n    },\n};\n/**\n * @private\n * Convert an api \"name\" into a full ApiDefinition\n * @param api\n * @returns\n */\nfunction expandApi(api) {\n    if (typeof api === \"string\" && api in SEARCH_APIS) {\n        return SEARCH_APIS[api];\n    }\n    else {\n        // it's an object, so we trust that it's well formed\n        return api;\n    }\n}\n/**\n * @private\n * Convert a field value into a MatchOptions if it's not already one\n * @param value\n * @returns\n */\nfunction valueToMatchOptions(value) {\n    let result = {};\n    if (Array.isArray(value)) {\n        result = {\n            any: value,\n        };\n    }\n    else {\n        if (typeof value === \"string\") {\n            result = {\n                any: [value],\n            };\n        }\n        if (typeof value === \"object\") {\n            result = value;\n        }\n    }\n    return result;\n}\n/**\n * @private\n * Convert a RelativeDate to a DateRange<number>\n * @param relative\n * @returns\n */\nfunction relativeDateToDateRange(relative) {\n    // hash of offsets\n    const offsetMs = {\n        min: 1000 * 60,\n        hours: 1000 * 60 * 60,\n        days: 1000 * 60 * 60 * 24,\n        weeks: 1000 * 60 * 60 * 24 * 7,\n    };\n    const now = new Date();\n    // default\n    const result = {\n        type: \"date-range\",\n        from: now.getTime(),\n        to: now.getTime(),\n    };\n    //\n    switch (relative.unit) {\n        case \"hours\":\n        case \"days\":\n        case \"weeks\":\n            result.from = result.to - offsetMs[relative.unit] * relative.num;\n            break;\n        case \"months\":\n            // get the current month and subtract num\n            // NOTE: when the previous month has fewer days than this month\n            // setMonth() will return a date w/in the current month\n            // example: 3/30 -> 3/2 b/c there is no 2/28\n            now.setMonth(now.getMonth() - relative.num);\n            result.from = now.getTime();\n            break;\n        case \"years\":\n            now.setFullYear(now.getFullYear() - relative.num);\n            result.from = now.getTime();\n            break;\n    }\n    return result;\n}\n/**\n * Create a `.next()` function for a type\n * @param request\n * @param nextStart\n * @param total\n * @param fn\n * @returns\n */\nfunction getNextFunction(request, nextStart, total, fn) {\n    const clonedRequest = cloneObject(request);\n    // clone will not handle authentication so we do it manually\n    if (request.authentication) {\n        clonedRequest.authentication = UserSession.deserialize(request.authentication.serialize());\n    }\n    // figure out the start\n    clonedRequest.start = nextStart > -1 ? nextStart : total + 1;\n    return (authentication) => {\n        if (authentication) {\n            clonedRequest.authentication = authentication;\n        }\n        return fn(clonedRequest);\n    };\n}\n/**\n * Construct a the full url to a group thumbnail\n *\n * - If the group has a thumbnail, construct the full url\n * - If the group is not public, append on the token (if passed in)\n * @param portalUrl\n * @param group\n * @param token\n * @returns\n */\nfunction getGroupThumbnailUrl(portalUrl, group, token) {\n    let thumbnailUrl = null;\n    if (group.thumbnail) {\n        thumbnailUrl = `${portalUrl}/community/groups/${group.id}/info/${group.thumbnail}`;\n        if (token && group.access !== \"public\") {\n            thumbnailUrl = `${thumbnailUrl}?token=${token}`;\n        }\n    }\n    return thumbnailUrl;\n}\n/**\n * Construct a the full url to a user thumbnail\n *\n * - If the user has a thumbnail, construct the full url\n * - If the user is not public, append on the token\n * @param portalUrl\n * @param user\n * @param token\n * @returns\n */\nfunction getUserThumbnailUrl(portalUrl, user, token) {\n    let thumbnailUrl = null;\n    if (user.thumbnail) {\n        thumbnailUrl = `${portalUrl}/community/users/${user.username}/info/${user.thumbnail}`;\n        if (token && user.access !== \"public\") {\n            thumbnailUrl = `${thumbnailUrl}?token=${token}`;\n        }\n    }\n    return thumbnailUrl;\n}\n\nexport { getUserThumbnailUrl as a, getNextFunction as b, expandApi as e, getGroupThumbnailUrl as g, relativeDateToDateRange as r, valueToMatchOptions as v };\n"],"names":["searchGroups","search","genericSearch","getGroupHomeUrl","groupId","portalUrlOrObject","portalUrl","getPortalUrl","getUserHomeUrl","username","enrichContentSearchResult","item","include","requestOptions","result","access","id","type","name","title","owner","tags","typeKeywords","categories","summary","snippet","description","createdDate","Date","created","createdDateSource","updatedDate","modified","updatedDateSource","family","getFamily","links","self","siteRelative","thumbnail","filter","unique","specs","map","parseInclude","enrichments","mapBy","enriched","length","fetchItemEnrichments","forEach","spec","prop","getProp","path","getItemThumbnailUrl","getItemHomeUrl","getHubRelativeUrl","handleEnrichmentError$1","error","input","opId","data","stack","finish","Object","assign","errors","getEnrichmentErrors","groupEnrichementOperations$1","membershipSummary","start","options","num","searchGroupUsers","group","then","results","total","users","catch","contentCount","searchGroupContent","fetchGroupEnrichments","operations","reduce","ops","enrichment","operation","push","createOperationPipeline","pipeline","OperationStack","output","expandPredicate","predicate","dateProps","copyProps","nonMatchOptionsFields","entries","key","value","includes","setProp","valueToMatchOptions","dateFieldValue","cloneObject","relativeDateToDateRange","hasOwnProperty","serializeQueryForPortal","query","mergeSearchOptions","filters","serializeFilter","removeEmptyEntries","e","acc","entry","q","predicates","searchOptions","serializePredicate","undefined","boolProps","passThroughProps","specialProps","portalAllowList","opts","so","any","serializeStringOrArray","all","not","serializeMatchOptions","range","from","to","serializeDateRange","join","Array","isArray","enrichPageSearchResult","convertPortalAggregations","searchResults","_a","aggregations","counts","mode","field","fieldName","values","fieldValues","portalSearchItems","HubError","updatedQuery","applyWellKnownItemPredicates","authentication","portal","aggFields","countFields","countSize","aggLimit","searchPortal$2","searchItems","resp","fn","itemToSearchResult","Promise","hasNext","nextStart","next","getNextFunction","enrichSiteSearchResult","enrichProjectSearchResult","WellKnownItemPredicates","$application","typekeywords","$dashboard","$dataset","$document","$initiative","$experience","$feedback","$page","$site","$storymap","$template","$webmap","queryClone","replacedPredicates","isWellKnownTypeFilter","replacements","formatOgcAggregationsResponse","response","ogcAgg","a","label","count","getOgcAggregationQueryParams","_query","token","getQueryString","queryParams","ogcApiRequest","url","_fetch","fetch","withQueryString","method","ok","RemoteServerError","statusText","status","json","searchOgcAggregations","apiDefinition","api","rawResponse","getNextOgcCallback","originalQuery","originalOptions","nextLink","find","l","rel","callback","URL","href","searchParams","get","nextOptions","searchOgcItems","ogcItemToSearchResult","ogcItem","properties","formatOgcItemsResponse","features","f","formattedResults","numberMatched","formatFilterBlock","formatted","formatPredicate","p","section","x","formatSimpleComparison","wrappedValues","maybeAddSingleQuotes","formatMultiStringPredicate","Number","isInteger","formatDateRangePredicate","anys","formatAnys","alls","v","formatAlls","nots","formatNots","subsection","formatComplexPredicate","test","getQQueryParam","qPredicate","Error","qPredicates","term","getQPredicate","getOgcItemQueryParams","getFilterQueryParam","limit","startindex","hubSearchItems","useBeta","portalSearchGroups","searchPortal$1","groupToSearchResult","enrichGroupSearchResult","handleEnrichmentError","groupEnrichementOperations","org","getPortalBaseFromOrgUrl","fetchOrg","user","orgId","fetchUserEnrichments","enrichUserSearchResult","fullName","getUserThumbnailUrl","portalSearchUsers","searchPortal","searchUsers","userToSearchResult","hubSearch","filterType","targetEntity","apiType","expandApi","fnHash","arcgis","isSharedUpdate","capabilities","membershipAccess","isOpenData","getGroupThumbnailUrl","fetchProject","identifier","getPrms","isGuid","getItem","getItemBySlug","convertItemToProject","fetchModelFromItem","model","fetchModelResources","EntityResourceMap","resources","mapper","PropertyMapper","getPropertyMap","prj","modelToObject","computeProps","getGroup","__assign","httpMethod","request","getGroupUsers","appendCustomParams","buildUrl","params","host","baseUrl","endsWith","keys","URLSearchParams","toString","buildQueryString","message","hubApiRequest","route","body","headers","JSON","stringify","getHubApiUrl","replace","SEARCH_APIS","arcgisQA","arcgisDEV","hub","hubDEV","hubQA","relative","now","getTime","unit","min","hours","days","weeks","setMonth","getMonth","setFullYear","getFullYear","clonedRequest","UserSession","serialize","thumbnailUrl"],"sourceRoot":""}