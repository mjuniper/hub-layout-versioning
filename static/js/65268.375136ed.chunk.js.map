{"version":3,"file":"static/js/65268.375136ed.chunk.js","mappings":"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","sources":["../.yalc/@esri/hub-components/dist/esm/_commonjsHelpers-11ca3be1.js","../.yalc/@esri/hub-components/dist/esm/parser-a04ddeb8.js"],"sourcesContent":["var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, basedir, module) {\n\treturn module = {\n\t\tpath: basedir,\n\t\texports: {},\n\t\trequire: function (path, base) {\n\t\t\treturn commonjsRequire();\n\t\t}\n\t}, fn(module, module.exports), module.exports;\n}\n\nfunction getAugmentedNamespace(n) {\n\tif (n.__esModule) return n;\n\tvar a = Object.defineProperty({}, '__esModule', {value: true});\n\tObject.keys(n).forEach(function (k) {\n\t\tvar d = Object.getOwnPropertyDescriptor(n, k);\n\t\tObject.defineProperty(a, k, d.get ? d : {\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn n[k];\n\t\t\t}\n\t\t});\n\t});\n\treturn a;\n}\n\nfunction commonjsRequire () {\n\tthrow new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\n}\n\nexport { commonjsGlobal as a, getDefaultExportFromCjs as b, createCommonjsModule as c, getAugmentedNamespace as g };\n","import { c as createCommonjsModule } from './_commonjsHelpers-11ca3be1.js';\n\nconst hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\nconst numRegex = /^([\\-\\+])?(0*)(\\.[0-9]+([eE]\\-?[0-9]+)?|[0-9]+(\\.[0-9]+([eE]\\-?[0-9]+)?)?)$/;\n// const octRegex = /0x[a-z0-9]+/;\n// const binRegex = /0x[a-z0-9]+/;\n\n\n//polyfill\nif (!Number.parseInt && window.parseInt) {\n    Number.parseInt = window.parseInt;\n}\nif (!Number.parseFloat && window.parseFloat) {\n    Number.parseFloat = window.parseFloat;\n}\n\n  \nconst consider = {\n    hex :  true,\n    leadingZeros: true,\n    decimalPoint: \"\\.\",\n    eNotation: true\n    //skipLike: /regex/\n};\n\nfunction toNumber(str, options = {}){\n    // const options = Object.assign({}, consider);\n    // if(opt.leadingZeros === false){\n    //     options.leadingZeros = false;\n    // }else if(opt.hex === false){\n    //     options.hex = false;\n    // }\n\n    options = Object.assign({}, consider, options );\n    if(!str || typeof str !== \"string\" ) return str;\n    \n    let trimmedStr  = str.trim();\n    // if(trimmedStr === \"0.0\") return 0;\n    // else if(trimmedStr === \"+0.0\") return 0;\n    // else if(trimmedStr === \"-0.0\") return -0;\n\n    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;\n    else if (options.hex && hexRegex.test(trimmedStr)) {\n        return Number.parseInt(trimmedStr, 16);\n    // } else if (options.parseOct && octRegex.test(str)) {\n    //     return Number.parseInt(val, 8);\n    // }else if (options.parseBin && binRegex.test(str)) {\n    //     return Number.parseInt(val, 2);\n    }else {\n        //separate negative sign, leading zeros, and rest number\n        const match = numRegex.exec(trimmedStr);\n        if(match){\n            const sign = match[1];\n            const leadingZeros = match[2];\n            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros\n            //trim ending zeros for floating number\n            \n            const eNotation = match[4] || match[6];\n            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== \".\") return str; //-0123\n            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== \".\") return str; //0123\n            else {//no leading zeros or leading zeros are allowed\n                const num = Number(trimmedStr);\n                const numStr = \"\" + num;\n                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(eNotation){ //given number has enotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(trimmedStr.indexOf(\".\") !== -1){ //floating number\n                    // const decimalPart = match[5].substr(1);\n                    // const intPart = trimmedStr.substr(0,trimmedStr.indexOf(\".\"));\n\n                    \n                    // const p = numStr.indexOf(\".\");\n                    // const givenIntPart = numStr.substr(0,p);\n                    // const givenDecPart = numStr.substr(p+1);\n                    if(numStr === \"0\" && (numTrimmedByZeros === \"\") ) return num; //0.0\n                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000\n                    else if( sign && numStr === \"-\"+numTrimmedByZeros) return num;\n                    else return str;\n                }\n                \n                if(leadingZeros){\n                    // if(numTrimmedByZeros === numStr){\n                    //     if(options.leadingZeros) return num;\n                    //     else return str;\n                    // }else return str;\n                    if(numTrimmedByZeros === numStr) return num;\n                    else if(sign+numTrimmedByZeros === numStr) return num;\n                    else return str;\n                }\n\n                if(trimmedStr === numStr) return num;\n                else if(trimmedStr === sign+numStr) return num;\n                // else{\n                //     //number with +/- sign\n                //     trimmedStr.test(/[-+][0-9]);\n\n                // }\n                return str;\n            }\n            // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;\n            \n        }else { //non-numeric string\n            return str;\n        }\n    }\n}\n\n/**\n * \n * @param {string} numStr without leading zeros\n * @returns \n */\nfunction trimZeros(numStr){\n    if(numStr && numStr.indexOf(\".\") !== -1){//float\n        numStr = numStr.replace(/0+$/, \"\"); //remove ending zeros\n        if(numStr === \".\")  numStr = \"0\";\n        else if(numStr[0] === \".\")  numStr = \"0\"+numStr;\n        else if(numStr[numStr.length-1] === \".\")  numStr = numStr.substr(0,numStr.length-1);\n        return numStr;\n    }\n    return numStr;\n}\nvar strnum = toNumber;\n\nvar util = createCommonjsModule(function (module, exports) {\n\nconst nameStartChar = ':A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\nconst nameChar = nameStartChar + '\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\nconst nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*';\nconst regexName = new RegExp('^' + nameRegexp + '$');\n\nconst getAllMatches = function(string, regex) {\n  const matches = [];\n  let match = regex.exec(string);\n  while (match) {\n    const allmatches = [];\n    allmatches.startIndex = regex.lastIndex - match[0].length;\n    const len = match.length;\n    for (let index = 0; index < len; index++) {\n      allmatches.push(match[index]);\n    }\n    matches.push(allmatches);\n    match = regex.exec(string);\n  }\n  return matches;\n};\n\nconst isName = function(string) {\n  const match = regexName.exec(string);\n  return !(match === null || typeof match === 'undefined');\n};\n\nexports.isExist = function(v) {\n  return typeof v !== 'undefined';\n};\n\nexports.isEmptyObject = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexports.merge = function(target, a, arrayMode) {\n  if (a) {\n    const keys = Object.keys(a); // will return an array of own properties\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      if (arrayMode === 'strict') {\n        target[keys[i]] = [ a[keys[i]] ];\n      } else {\n        target[keys[i]] = a[keys[i]];\n      }\n    }\n  }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexports.getValue = function(v) {\n  if (exports.isExist(v)) {\n    return v;\n  } else {\n    return '';\n  }\n};\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\n\nexports.buildOptions = function(options, defaultOptions, props) {\n  let newOptions = {};\n  if (!options) {\n    return defaultOptions; //if there are not options\n  }\n\n  for (let i = 0; i < props.length; i++) {\n    if (options[props[i]] !== undefined) {\n      newOptions[props[i]] = options[props[i]];\n    } else {\n      newOptions[props[i]] = defaultOptions[props[i]];\n    }\n  }\n  return newOptions;\n};\n\n/**\n * Check if a tag name should be treated as array\n *\n * @param tagName the node tagname\n * @param arrayMode the array mode option\n * @param parentTagName the parent tag name\n * @returns {boolean} true if node should be parsed as array\n */\nexports.isTagNameInArrayMode = function (tagName, arrayMode, parentTagName) {\n  if (arrayMode === false) {\n    return false;\n  } else if (arrayMode instanceof RegExp) {\n    return arrayMode.test(tagName);\n  } else if (typeof arrayMode === 'function') {\n    return !!arrayMode(tagName, parentTagName);\n  }\n\n  return arrayMode === \"strict\";\n};\n\nexports.isName = isName;\nexports.getAllMatches = getAllMatches;\nexports.nameRegexp = nameRegexp;\n});\n\nconst convertToJson = function(node, options, parentTagName) {\n  const jObj = {};\n\n  // when no child node or attr is present\n  if (!options.alwaysCreateTextNode && (!node.child || util.isEmptyObject(node.child)) && (!node.attrsMap || util.isEmptyObject(node.attrsMap))) {\n    return util.isExist(node.val) ? node.val : '';\n  }\n\n  // otherwise create a textnode if node has some text\n  if (util.isExist(node.val) && !(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {\n    const asArray = util.isTagNameInArrayMode(node.tagname, options.arrayMode, parentTagName);\n    jObj[options.textNodeName] = asArray ? [node.val] : node.val;\n  }\n\n  util.merge(jObj, node.attrsMap, options.arrayMode);\n\n  const keys = Object.keys(node.child);\n  for (let index = 0; index < keys.length; index++) {\n    const tagName = keys[index];\n    if (node.child[tagName] && node.child[tagName].length > 1) {\n      jObj[tagName] = [];\n      for (let tag in node.child[tagName]) {\n        if (node.child[tagName].hasOwnProperty(tag)) {\n          jObj[tagName].push(convertToJson(node.child[tagName][tag], options, tagName));\n        }\n      }\n    } else {\n      const result = convertToJson(node.child[tagName][0], options, tagName);\n      const asArray = (options.arrayMode === true && typeof result === 'object') || util.isTagNameInArrayMode(tagName, options.arrayMode, parentTagName);\n      jObj[tagName] = asArray ? [result] : result;\n    }\n  }\n\n  //add value\n  return jObj;\n};\n\nvar convertToJson_1 = convertToJson;\n\nvar node2json = {\n\tconvertToJson: convertToJson_1\n};\n\nvar xmlNode = function(tagname, parent, val) {\n  this.tagname = tagname;\n  this.parent = parent;\n  this.child = {}; //child tags\n  this.attrsMap = {}; //attributes map\n  this.val = val; //text only\n  this.addChild = function(child) {\n    if (Array.isArray(this.child[child.tagname])) {\n      //already presents\n      this.child[child.tagname].push(child);\n    } else {\n      this.child[child.tagname] = [child];\n    }\n  };\n};\n\nconst buildOptions$3 = util.buildOptions;\n\n\n\n'<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n  .replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\n//polyfill\nif (!Number.parseInt && window.parseInt) {\n  Number.parseInt = window.parseInt;\n}\nif (!Number.parseFloat && window.parseFloat) {\n  Number.parseFloat = window.parseFloat;\n}\n\nconst defaultOptions$2 = {\n  attributeNamePrefix: '@_',\n  attrNodeName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  ignoreNameSpace: false,\n  allowBooleanAttributes: false, //a tag can have attributes without any value\n  //ignoreRootElement : false,\n  parseNodeValue: true,\n  parseAttributeValue: false,\n  arrayMode: false,\n  trimValues: true, //Trim string values of tag and attributes\n  cdataTagName: false,\n  cdataPositionChar: '\\\\c',\n  numParseOptions: {\n    hex: true,\n    leadingZeros: true\n  },\n  tagValueProcessor: function(a, tagName) {\n    return a;\n  },\n  attrValueProcessor: function(a, attrName) {\n    return a;\n  },\n  stopNodes: [],\n  alwaysCreateTextNode: false\n  //decodeStrict: false,\n};\n\nvar defaultOptions_1 = defaultOptions$2;\n\nconst props$2 = [\n  'attributeNamePrefix',\n  'attrNodeName',\n  'textNodeName',\n  'ignoreAttributes',\n  'ignoreNameSpace',\n  'allowBooleanAttributes',\n  'parseNodeValue',\n  'parseAttributeValue',\n  'arrayMode',\n  'trimValues',\n  'cdataTagName',\n  'cdataPositionChar',\n  'tagValueProcessor',\n  'attrValueProcessor',\n  'parseTrueNumberOnly',\n  'numParseOptions',\n  'stopNodes',\n  'alwaysCreateTextNode'\n];\nvar props_1 = props$2;\n\n/**\n * Trim -> valueProcessor -> parse value\n * @param {string} tagName\n * @param {string} val\n * @param {object} options\n */\nfunction processTagValue(tagName, val, options) {\n  if (val) {\n    if (options.trimValues) {\n      val = val.trim();\n    }\n    val = options.tagValueProcessor(val, tagName);\n    val = parseValue(val, options.parseNodeValue, options.numParseOptions);\n  }\n\n  return val;\n}\n\nfunction resolveNameSpace(tagname, options) {\n  if (options.ignoreNameSpace) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\nfunction parseValue(val, shouldParse, options) {\n  if (shouldParse && typeof val === 'string') {\n    //console.log(options)\n    const newval = val.trim();\n    if(newval === 'true' ) return true;\n    else if(newval === 'false' ) return false;\n    else return strnum(val, options);\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])(.*?)\\\\3)?', 'g');\n\nfunction buildAttributesMap(attrStr, options) {\n  if (!options.ignoreAttributes && typeof attrStr === 'string') {\n    attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = resolveNameSpace(matches[i][1], options);\n      if (attrName.length) {\n        if (matches[i][4] !== undefined) {\n          if (options.trimValues) {\n            matches[i][4] = matches[i][4].trim();\n          }\n          matches[i][4] = options.attrValueProcessor(matches[i][4], attrName);\n          attrs[options.attributeNamePrefix + attrName] = parseValue(\n            matches[i][4],\n            options.parseAttributeValue,\n            options.numParseOptions\n          );\n        } else if (options.allowBooleanAttributes) {\n          attrs[options.attributeNamePrefix + attrName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (options.attrNodeName) {\n      const attrCollection = {};\n      attrCollection[options.attrNodeName] = attrs;\n      return attrCollection;\n    }\n    return attrs;\n  }\n}\n\nconst getTraversalObj = function(xmlData, options) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\");\n  options = buildOptions$3(options, defaultOptions$2, props$2);\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n\n//function match(xmlData){\n  for(let i=0; i< xmlData.length; i++){\n    const ch = xmlData[i];\n    if(ch === '<'){\n      if( xmlData[i+1] === '/') {//Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\");\n        let tagName = xmlData.substring(i+2,closeIndex).trim();\n\n        if(options.ignoreNameSpace){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n          }\n        }\n\n        /* if (currentNode.parent) {\n          currentNode.parent.val = util.getValue(currentNode.parent.val) + '' + processTagValue2(tagName, textData , options);\n        } */\n        if(currentNode){\n          if(currentNode.val){\n            currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(tagName, textData , options);\n          }else {\n            currentNode.val = processTagValue(tagName, textData , options);\n          }\n        }\n\n        if (options.stopNodes.length && options.stopNodes.includes(currentNode.tagname)) {\n          currentNode.child = [];\n          if (currentNode.attrsMap == undefined) { currentNode.attrsMap = {};}\n          currentNode.val = xmlData.substr(currentNode.startIndex + 1, i - currentNode.startIndex - 1);\n        }\n        currentNode = currentNode.parent;\n        textData = \"\";\n        i = closeIndex;\n      } else if( xmlData[i+1] === '?') {\n        i = findClosingIndex(xmlData, \"?>\", i, \"Pi Tag is not closed.\");\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\n        i = findClosingIndex(xmlData, \"-->\", i, \"Comment is not closed.\");\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"DOCTYPE is not closed.\");\n        const tagExp = xmlData.substring(i, closeIndex);\n        if(tagExp.indexOf(\"[\") >= 0){\n          i = xmlData.indexOf(\"]>\", i) + 1;\n        }else {\n          i = closeIndex;\n        }\n      }else if(xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n        const tagExp = xmlData.substring(i + 9,closeIndex);\n\n        //considerations\n        //1. CDATA will always have parent node\n        //2. A tag with CDATA is not a leaf node so it's value would be string type.\n        if(textData){\n          currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(currentNode.tagname, textData , options);\n          textData = \"\";\n        }\n\n        if (options.cdataTagName) {\n          //add cdata node\n          const childNode = new xmlNode(options.cdataTagName, currentNode, tagExp);\n          currentNode.addChild(childNode);\n          //for backtracking\n          currentNode.val = util.getValue(currentNode.val) + options.cdataPositionChar;\n          //add rest value to parent node\n          if (tagExp) {\n            childNode.val = tagExp;\n          }\n        } else {\n          currentNode.val = (currentNode.val || '') + (tagExp || '');\n        }\n\n        i = closeIndex + 2;\n      }else {//Opening tag\n        const result = closingIndexForOpeningTag(xmlData, i+1);\n        let tagExp = result.data;\n        const closeIndex = result.index;\n        const separatorIndex = tagExp.indexOf(\" \");\n        let tagName = tagExp;\n        let shouldBuildAttributesMap = true;\n        if(separatorIndex !== -1){\n          tagName = tagExp.substr(0, separatorIndex).replace(/\\s\\s*$/, '');\n          tagExp = tagExp.substr(separatorIndex + 1);\n        }\n\n        if(options.ignoreNameSpace){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n            shouldBuildAttributesMap = tagName !== result.data.substr(colonIndex + 1);\n          }\n        }\n\n        //save text to parent node\n        if (currentNode && textData) {\n          if(currentNode.tagname !== '!xml'){\n            currentNode.val = util.getValue(currentNode.val) + '' + processTagValue( currentNode.tagname, textData, options);\n          }\n        }\n\n        if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){//selfClosing tag\n\n          if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n            tagName = tagName.substr(0, tagName.length - 1);\n            tagExp = tagName;\n          }else {\n            tagExp = tagExp.substr(0, tagExp.length - 1);\n          }\n\n          const childNode = new xmlNode(tagName, currentNode, '');\n          if(tagName !== tagExp){\n            childNode.attrsMap = buildAttributesMap(tagExp, options);\n          }\n          currentNode.addChild(childNode);\n        }else {//opening tag\n\n          const childNode = new xmlNode( tagName, currentNode );\n          if (options.stopNodes.length && options.stopNodes.includes(childNode.tagname)) {\n            childNode.startIndex=closeIndex;\n          }\n          if(tagName !== tagExp && shouldBuildAttributesMap){\n            childNode.attrsMap = buildAttributesMap(tagExp, options);\n          }\n          currentNode.addChild(childNode);\n          currentNode = childNode;\n        }\n        textData = \"\";\n        i = closeIndex;\n      }\n    }else {\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj;\n};\n\nfunction closingIndexForOpeningTag(data, i){\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < data.length; index++) {\n    let ch = data[index];\n    if (attrBoundary) {\n        if (ch === attrBoundary) attrBoundary = \"\";//reset\n    } else if (ch === '\"' || ch === \"'\") {\n        attrBoundary = ch;\n    } else if (ch === '>') {\n        return {\n          data: tagExp,\n          index: index\n        }\n    } else if (ch === '\\t') {\n      ch = \" \";\n    }\n    tagExp += ch;\n  }\n}\n\nfunction findClosingIndex(xmlData, str, i, errMsg){\n  const closingIndex = xmlData.indexOf(str, i);\n  if(closingIndex === -1){\n    throw new Error(errMsg)\n  }else {\n    return closingIndex + str.length - 1;\n  }\n}\n\nvar getTraversalObj_1 = getTraversalObj;\n\nvar xmlstr2xmlnode = {\n\tdefaultOptions: defaultOptions_1,\n\tprops: props_1,\n\tgetTraversalObj: getTraversalObj_1\n};\n\nconst defaultOptions$1 = {\n  allowBooleanAttributes: false, //A tag can have attributes without any value\n};\n\nconst props$1 = ['allowBooleanAttributes'];\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nvar validate = function (xmlData, options) {\n  options = util.buildOptions(options, defaultOptions$1, props$1);\n\n  //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n  //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n  //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n  const tags = [];\n  let tagFound = false;\n\n  //indicates that the root tag has been closed (aka. depth 0 has been reached)\n  let reachedRoot = false;\n\n  if (xmlData[0] === '\\ufeff') {\n    // check for byte order mark (BOM)\n    xmlData = xmlData.substr(1);\n  }\n\n  for (let i = 0; i < xmlData.length; i++) {\n\n    if (xmlData[i] === '<' && xmlData[i+1] === '?') {\n      i+=2;\n      i = readPI(xmlData,i);\n      if (i.err) return i;\n    }else if (xmlData[i] === '<') {\n      //starting of tag\n      //read until you reach to '>' avoiding any '>' in attribute value\n      let tagStartPos = i;\n      i++;\n      \n      if (xmlData[i] === '!') {\n        i = readCommentAndCDATA(xmlData, i);\n        continue;\n      } else {\n        let closingTag = false;\n        if (xmlData[i] === '/') {\n          //closing tag\n          closingTag = true;\n          i++;\n        }\n        //read tagname\n        let tagName = '';\n        for (; i < xmlData.length &&\n          xmlData[i] !== '>' &&\n          xmlData[i] !== ' ' &&\n          xmlData[i] !== '\\t' &&\n          xmlData[i] !== '\\n' &&\n          xmlData[i] !== '\\r'; i++\n        ) {\n          tagName += xmlData[i];\n        }\n        tagName = tagName.trim();\n        //console.log(tagName);\n\n        if (tagName[tagName.length - 1] === '/') {\n          //self closing tag without attributes\n          tagName = tagName.substring(0, tagName.length - 1);\n          //continue;\n          i--;\n        }\n        if (!validateTagName(tagName)) {\n          let msg;\n          if (tagName.trim().length === 0) {\n            msg = \"Invalid space after '<'.\";\n          } else {\n            msg = \"Tag '\"+tagName+\"' is an invalid name.\";\n          }\n          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));\n        }\n\n        const result = readAttributeStr(xmlData, i);\n        if (result === false) {\n          return getErrorObject('InvalidAttr', \"Attributes for '\"+tagName+\"' have open quote.\", getLineNumberForPosition(xmlData, i));\n        }\n        let attrStr = result.value;\n        i = result.index;\n\n        if (attrStr[attrStr.length - 1] === '/') {\n          //self closing tag\n          const attrStrStart = i - attrStr.length;\n          attrStr = attrStr.substring(0, attrStr.length - 1);\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid === true) {\n            tagFound = true;\n            //continue; //text may presents after self closing tag\n          } else {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));\n          }\n        } else if (closingTag) {\n          if (!result.tagClosed) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' doesn't have proper closing.\", getLineNumberForPosition(xmlData, i));\n          } else if (attrStr.trim().length > 0) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' can't have attributes or invalid starting.\", getLineNumberForPosition(xmlData, tagStartPos));\n          } else {\n            const otg = tags.pop();\n            if (tagName !== otg.tagName) {\n              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\n              return getErrorObject('InvalidTag',\n                \"Expected closing tag '\"+otg.tagName+\"' (opened in line \"+openPos.line+\", col \"+openPos.col+\") instead of closing tag '\"+tagName+\"'.\",\n                getLineNumberForPosition(xmlData, tagStartPos));\n            }\n\n            //when there are no more tags, we reached the root level.\n            if (tags.length == 0) {\n              reachedRoot = true;\n            }\n          }\n        } else {\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid !== true) {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\n          }\n\n          //if the root level has been reached before ...\n          if (reachedRoot === true) {\n            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));\n          } else {\n            tags.push({tagName, tagStartPos});\n          }\n          tagFound = true;\n        }\n\n        //skip tag text value\n        //It may include comments and CDATA value\n        for (i++; i < xmlData.length; i++) {\n          if (xmlData[i] === '<') {\n            if (xmlData[i + 1] === '!') {\n              //comment or CADATA\n              i++;\n              i = readCommentAndCDATA(xmlData, i);\n              continue;\n            } else if (xmlData[i+1] === '?') {\n              i = readPI(xmlData, ++i);\n              if (i.err) return i;\n            } else {\n              break;\n            }\n          } else if (xmlData[i] === '&') {\n            const afterAmp = validateAmpersand(xmlData, i);\n            if (afterAmp == -1)\n              return getErrorObject('InvalidChar', \"char '&' is not expected.\", getLineNumberForPosition(xmlData, i));\n            i = afterAmp;\n          }\n        } //end of reading tag text value\n        if (xmlData[i] === '<') {\n          i--;\n        }\n      }\n    } else {\n      if (xmlData[i] === ' ' || xmlData[i] === '\\t' || xmlData[i] === '\\n' || xmlData[i] === '\\r') {\n        continue;\n      }\n      return getErrorObject('InvalidChar', \"char '\"+xmlData[i]+\"' is not expected.\", getLineNumberForPosition(xmlData, i));\n    }\n  }\n\n  if (!tagFound) {\n    return getErrorObject('InvalidXml', 'Start tag expected.', 1);\n  }else if (tags.length == 1) {\n      return getErrorObject('InvalidTag', \"Unclosed tag '\"+tags[0].tagName+\"'.\", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\n  }else if (tags.length > 0) {\n      return getErrorObject('InvalidXml', \"Invalid '\"+\n          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\\r?\\n/g, '')+\n          \"' found.\", {line: 1, col: 1});\n  }\n\n  return true;\n};\n\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n  const start = i;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] == '?' || xmlData[i] == ' ') {\n      //tagname\n      const tagname = xmlData.substr(start, i - start);\n      if (i > 5 && tagname === 'xml') {\n        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));\n      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {\n        //check if valid attribut string\n        i++;\n        break;\n      } else {\n        continue;\n      }\n    }\n  }\n  return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {\n    //comment\n    for (i += 3; i < xmlData.length; i++) {\n      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  } else if (\n    xmlData.length > i + 8 &&\n    xmlData[i + 1] === 'D' &&\n    xmlData[i + 2] === 'O' &&\n    xmlData[i + 3] === 'C' &&\n    xmlData[i + 4] === 'T' &&\n    xmlData[i + 5] === 'Y' &&\n    xmlData[i + 6] === 'P' &&\n    xmlData[i + 7] === 'E'\n  ) {\n    let angleBracketsCount = 1;\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === '<') {\n        angleBracketsCount++;\n      } else if (xmlData[i] === '>') {\n        angleBracketsCount--;\n        if (angleBracketsCount === 0) {\n          break;\n        }\n      }\n    }\n  } else if (\n    xmlData.length > i + 9 &&\n    xmlData[i + 1] === '[' &&\n    xmlData[i + 2] === 'C' &&\n    xmlData[i + 3] === 'D' &&\n    xmlData[i + 4] === 'A' &&\n    xmlData[i + 5] === 'T' &&\n    xmlData[i + 6] === 'A' &&\n    xmlData[i + 7] === '['\n  ) {\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  }\n\n  return i;\n}\n\nconst doubleQuote = '\"';\nconst singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n  let attrStr = '';\n  let startChar = '';\n  let tagClosed = false;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n      if (startChar === '') {\n        startChar = xmlData[i];\n      } else if (startChar !== xmlData[i]) ; else {\n        startChar = '';\n      }\n    } else if (xmlData[i] === '>') {\n      if (startChar === '') {\n        tagClosed = true;\n        break;\n      }\n    }\n    attrStr += xmlData[i];\n  }\n  if (startChar !== '') {\n    return false;\n  }\n\n  return {\n    value: attrStr,\n    index: i,\n    tagClosed: tagClosed\n  };\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp('(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*([\\'\"])(([\\\\s\\\\S])*?)\\\\5)?', 'g');\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options) {\n  //console.log(\"start:\"+attrStr+\":end\");\n\n  //if(attrStr.trim().length === 0) return true; //empty string\n\n  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n  const attrNames = {};\n\n  for (let i = 0; i < matches.length; i++) {\n    if (matches[i][1].length === 0) {\n      //nospace before attribute name: a=\"sd\"b=\"saf\"\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' has no space in starting.\", getPositionFromMatch(matches[i]))\n    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {\n      //independent attribute: ab\n      return getErrorObject('InvalidAttr', \"boolean attribute '\"+matches[i][2]+\"' is not allowed.\", getPositionFromMatch(matches[i]));\n    }\n    /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n    const attrName = matches[i][2];\n    if (!validateAttrName(attrName)) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is an invalid name.\", getPositionFromMatch(matches[i]));\n    }\n    if (!attrNames.hasOwnProperty(attrName)) {\n      //check for duplicate attribute.\n      attrNames[attrName] = 1;\n    } else {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is repeated.\", getPositionFromMatch(matches[i]));\n    }\n  }\n\n  return true;\n}\n\nfunction validateNumberAmpersand(xmlData, i) {\n  let re = /\\d/;\n  if (xmlData[i] === 'x') {\n    i++;\n    re = /[\\da-fA-F]/;\n  }\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === ';')\n      return i;\n    if (!xmlData[i].match(re))\n      break;\n  }\n  return -1;\n}\n\nfunction validateAmpersand(xmlData, i) {\n  // https://www.w3.org/TR/xml/#dt-charref\n  i++;\n  if (xmlData[i] === ';')\n    return -1;\n  if (xmlData[i] === '#') {\n    i++;\n    return validateNumberAmpersand(xmlData, i);\n  }\n  let count = 0;\n  for (; i < xmlData.length; i++, count++) {\n    if (xmlData[i].match(/\\w/) && count < 20)\n      continue;\n    if (xmlData[i] === ';')\n      break;\n    return -1;\n  }\n  return i;\n}\n\nfunction getErrorObject(code, message, lineNumber) {\n  return {\n    err: {\n      code: code,\n      msg: message,\n      line: lineNumber.line || lineNumber,\n      col: lineNumber.col,\n    },\n  };\n}\n\nfunction validateAttrName(attrName) {\n  return util.isName(attrName);\n}\n\n// const startsWithXML = /^xml/i;\n\nfunction validateTagName(tagname) {\n  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;\n}\n\n//this function returns the line number for the character at the given index\nfunction getLineNumberForPosition(xmlData, index) {\n  const lines = xmlData.substring(0, index).split(/\\r?\\n/);\n  return {\n    line: lines.length,\n\n    // column number is last line's length + 1, because column numbering starts at 1:\n    col: lines[lines.length - 1].length + 1\n  };\n}\n\n//this function returns the position of the first character of match within attrStr\nfunction getPositionFromMatch(match) {\n  return match.startIndex + match[1].length;\n}\n\nvar validator = {\n\tvalidate: validate\n};\n\nconst char = function(a) {\n  return String.fromCharCode(a);\n};\n\nconst chars = {\n  nilChar: char(176),\n  missingChar: char(201),\n  nilPremitive: char(175),\n  missingPremitive: char(200),\n\n  emptyChar: char(178),\n  emptyValue: char(177), //empty Premitive\n\n  boundryChar: char(179),\n\n  objStart: char(198),\n  arrStart: char(204),\n  arrayEnd: char(185),\n};\n\nconst charsArr = [\n  chars.nilChar,\n  chars.nilPremitive,\n  chars.missingChar,\n  chars.missingPremitive,\n  chars.boundryChar,\n  chars.emptyChar,\n  chars.emptyValue,\n  chars.arrayEnd,\n  chars.objStart,\n  chars.arrStart,\n];\n\nconst _e = function(node, e_schema, options) {\n  if (typeof e_schema === 'string') {\n    //premitive\n    if (node && node[0] && node[0].val !== undefined) {\n      return getValue(node[0].val);\n    } else {\n      return getValue(node);\n    }\n  } else {\n    const hasValidData = hasData(node);\n    if (hasValidData === true) {\n      let str = '';\n      if (Array.isArray(e_schema)) {\n        //attributes can't be repeated. hence check in children tags only\n        str += chars.arrStart;\n        const itemSchema = e_schema[0];\n        //const itemSchemaType = itemSchema;\n        const arr_len = node.length;\n\n        if (typeof itemSchema === 'string') {\n          for (let arr_i = 0; arr_i < arr_len; arr_i++) {\n            const r = getValue(node[arr_i].val);\n            str = processValue(str, r);\n          }\n        } else {\n          for (let arr_i = 0; arr_i < arr_len; arr_i++) {\n            const r = _e(node[arr_i], itemSchema, options);\n            str = processValue(str, r);\n          }\n        }\n        str += chars.arrayEnd; //indicates that next item is not array item\n      } else {\n        //object\n        str += chars.objStart;\n        const keys = Object.keys(e_schema);\n        if (Array.isArray(node)) {\n          node = node[0];\n        }\n        for (let i in keys) {\n          const key = keys[i];\n          //a property defined in schema can be present either in attrsMap or children tags\n          //options.textNodeName will not present in both maps, take it's value from val\n          //options.attrNodeName will be present in attrsMap\n          let r;\n          if (!options.ignoreAttributes && node.attrsMap && node.attrsMap[key]) {\n            r = _e(node.attrsMap[key], e_schema[key], options);\n          } else if (key === options.textNodeName) {\n            r = _e(node.val, e_schema[key], options);\n          } else {\n            r = _e(node.child[key], e_schema[key], options);\n          }\n          str = processValue(str, r);\n        }\n      }\n      return str;\n    } else {\n      return hasValidData;\n    }\n  }\n};\n\nconst getValue = function(a /*, type*/) {\n  switch (a) {\n    case undefined:\n      return chars.missingPremitive;\n    case null:\n      return chars.nilPremitive;\n    case '':\n      return chars.emptyValue;\n    default:\n      return a;\n  }\n};\n\nconst processValue = function(str, r) {\n  if (!isAppChar(r[0]) && !isAppChar(str[str.length - 1])) {\n    str += chars.boundryChar;\n  }\n  return str + r;\n};\n\nconst isAppChar = function(ch) {\n  return charsArr.indexOf(ch) !== -1;\n};\n\nfunction hasData(jObj) {\n  if (jObj === undefined) {\n    return chars.missingChar;\n  } else if (jObj === null) {\n    return chars.nilChar;\n  } else if (\n    jObj.child &&\n    Object.keys(jObj.child).length === 0 &&\n    (!jObj.attrsMap || Object.keys(jObj.attrsMap).length === 0)\n  ) {\n    return chars.emptyChar;\n  } else {\n    return true;\n  }\n}\n\n\nconst buildOptions$2 = util.buildOptions;\n\nconst convert2nimn = function(node, e_schema, options) {\n  options = buildOptions$2(options, xmlstr2xmlnode.defaultOptions, xmlstr2xmlnode.props);\n  return _e(node, e_schema, options);\n};\n\nvar convert2nimn_1 = convert2nimn;\n\nvar nimndata = {\n\tconvert2nimn: convert2nimn_1\n};\n\nconst buildOptions$1 = util.buildOptions;\n\n\n//TODO: do it later\nconst convertToJsonString = function(node, options) {\n  options = buildOptions$1(options, xmlstr2xmlnode.defaultOptions, xmlstr2xmlnode.props);\n\n  options.indentBy = options.indentBy || '';\n  return _cToJsonStr(node, options);\n};\n\nconst _cToJsonStr = function(node, options, level) {\n  let jObj = '{';\n\n  //traver through all the children\n  const keys = Object.keys(node.child);\n\n  for (let index = 0; index < keys.length; index++) {\n    const tagname = keys[index];\n    if (node.child[tagname] && node.child[tagname].length > 1) {\n      jObj += '\"' + tagname + '\" : [ ';\n      for (let tag in node.child[tagname]) {\n        jObj += _cToJsonStr(node.child[tagname][tag], options) + ' , ';\n      }\n      jObj = jObj.substr(0, jObj.length - 1) + ' ] '; //remove extra comma in last\n    } else {\n      jObj += '\"' + tagname + '\" : ' + _cToJsonStr(node.child[tagname][0], options) + ' ,';\n    }\n  }\n  util.merge(jObj, node.attrsMap);\n  //add attrsMap as new children\n  if (util.isEmptyObject(jObj)) {\n    return util.isExist(node.val) ? node.val : '';\n  } else {\n    if (util.isExist(node.val)) {\n      if (!(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {\n        jObj += '\"' + options.textNodeName + '\" : ' + stringval(node.val);\n      }\n    }\n  }\n  //add value\n  if (jObj[jObj.length - 1] === ',') {\n    jObj = jObj.substr(0, jObj.length - 2);\n  }\n  return jObj + '}';\n};\n\nfunction stringval(v) {\n  if (v === true || v === false || !isNaN(v)) {\n    return v;\n  } else {\n    return '\"' + v + '\"';\n  }\n}\n\nvar convertToJsonString_1 = convertToJsonString;\n\nvar node2json_str = {\n\tconvertToJsonString: convertToJsonString_1\n};\n\n//parse Empty Node as self closing node\nconst buildOptions = util.buildOptions;\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attrNodeName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  cdataTagName: false,\n  cdataPositionChar: '\\\\c',\n  format: false,\n  indentBy: '  ',\n  supressEmptyNode: false,\n  tagValueProcessor: function(a) {\n    return a;\n  },\n  attrValueProcessor: function(a) {\n    return a;\n  },\n};\n\nconst props = [\n  'attributeNamePrefix',\n  'attrNodeName',\n  'textNodeName',\n  'ignoreAttributes',\n  'cdataTagName',\n  'cdataPositionChar',\n  'format',\n  'indentBy',\n  'supressEmptyNode',\n  'tagValueProcessor',\n  'attrValueProcessor',\n  'rootNodeName', //when array as root\n];\n\nfunction Parser(options) {\n  this.options = buildOptions(options, defaultOptions, props);\n  if (this.options.ignoreAttributes || this.options.attrNodeName) {\n    this.isAttribute = function(/*a*/) {\n      return false;\n    };\n  } else {\n    this.attrPrefixLen = this.options.attributeNamePrefix.length;\n    this.isAttribute = isAttribute;\n  }\n  if (this.options.cdataTagName) {\n    this.isCDATA = isCDATA;\n  } else {\n    this.isCDATA = function(/*a*/) {\n      return false;\n    };\n  }\n  this.replaceCDATAstr = replaceCDATAstr;\n  this.replaceCDATAarr = replaceCDATAarr;\n\n  this.processTextOrObjNode = processTextOrObjNode;\n\n  if (this.options.format) {\n    this.indentate = indentate;\n    this.tagEndChar = '>\\n';\n    this.newLine = '\\n';\n  } else {\n    this.indentate = function() {\n      return '';\n    };\n    this.tagEndChar = '>';\n    this.newLine = '';\n  }\n\n  if (this.options.supressEmptyNode) {\n    this.buildTextNode = buildEmptyTextNode;\n    this.buildObjNode = buildEmptyObjNode;\n  } else {\n    this.buildTextNode = buildTextValNode;\n    this.buildObjNode = buildObjectNode;\n  }\n\n  this.buildTextValNode = buildTextValNode;\n  this.buildObjectNode = buildObjectNode;\n}\n\nParser.prototype.parse = function(jObj) {\n  if(Array.isArray(jObj) && this.options.rootNodeName && this.options.rootNodeName.length > 1){\n    jObj = {\n      [this.options.rootNodeName] : jObj\n    };\n  }\n  return this.j2x(jObj, 0).val;\n};\n\nParser.prototype.j2x = function(jObj, level) {\n  let attrStr = '';\n  let val = '';\n  for (let key in jObj) {\n    if (typeof jObj[key] === 'undefined') ; else if (jObj[key] === null) {\n      val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n    } else if (jObj[key] instanceof Date) {\n      val += this.buildTextNode(jObj[key], key, '', level);\n    } else if (typeof jObj[key] !== 'object') {\n      //premitive type\n      const attr = this.isAttribute(key);\n      if (attr) {\n        attrStr += ' ' + attr + '=\"' + this.options.attrValueProcessor('' + jObj[key]) + '\"';\n      } else if (this.isCDATA(key)) {\n        if (jObj[this.options.textNodeName]) {\n          val += this.replaceCDATAstr(jObj[this.options.textNodeName], jObj[key]);\n        } else {\n          val += this.replaceCDATAstr('', jObj[key]);\n        }\n      } else {\n        //tag value\n        if (key === this.options.textNodeName) {\n          if (jObj[this.options.cdataTagName]) ; else {\n            val += this.options.tagValueProcessor('' + jObj[key]);\n          }\n        } else {\n          val += this.buildTextNode(jObj[key], key, '', level);\n        }\n      }\n    } else if (Array.isArray(jObj[key])) {\n      //repeated nodes\n      if (this.isCDATA(key)) {\n        val += this.indentate(level);\n        if (jObj[this.options.textNodeName]) {\n          val += this.replaceCDATAarr(jObj[this.options.textNodeName], jObj[key]);\n        } else {\n          val += this.replaceCDATAarr('', jObj[key]);\n        }\n      } else {\n        //nested nodes\n        const arrLen = jObj[key].length;\n        for (let j = 0; j < arrLen; j++) {\n          const item = jObj[key][j];\n          if (typeof item === 'undefined') ; else if (item === null) {\n            val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n          } else if (typeof item === 'object') {\n            val += this.processTextOrObjNode(item, key, level);\n          } else {\n            val += this.buildTextNode(item, key, '', level);\n          }\n        }\n      }\n    } else {\n      //nested node\n      if (this.options.attrNodeName && key === this.options.attrNodeName) {\n        const Ks = Object.keys(jObj[key]);\n        const L = Ks.length;\n        for (let j = 0; j < L; j++) {\n          attrStr += ' ' + Ks[j] + '=\"' + this.options.attrValueProcessor('' + jObj[key][Ks[j]]) + '\"';\n        }\n      } else {\n        val += this.processTextOrObjNode(jObj[key], key, level);\n      }\n    }\n  }\n  return {attrStr: attrStr, val: val};\n};\n\nfunction processTextOrObjNode (object, key, level) {\n  const result = this.j2x(object, level + 1);\n  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {\n    return this.buildTextNode(result.val, key, result.attrStr, level);\n  } else {\n    return this.buildObjNode(result.val, key, result.attrStr, level);\n  }\n}\n\nfunction replaceCDATAstr(str, cdata) {\n  str = this.options.tagValueProcessor('' + str);\n  if (this.options.cdataPositionChar === '' || str === '') {\n    return str + '<![CDATA[' + cdata + ']]' + this.tagEndChar;\n  } else {\n    return str.replace(this.options.cdataPositionChar, '<![CDATA[' + cdata + ']]' + this.tagEndChar);\n  }\n}\n\nfunction replaceCDATAarr(str, cdata) {\n  str = this.options.tagValueProcessor('' + str);\n  if (this.options.cdataPositionChar === '' || str === '') {\n    return str + '<![CDATA[' + cdata.join(']]><![CDATA[') + ']]' + this.tagEndChar;\n  } else {\n    for (let v in cdata) {\n      str = str.replace(this.options.cdataPositionChar, '<![CDATA[' + cdata[v] + ']]>');\n    }\n    return str + this.newLine;\n  }\n}\n\nfunction buildObjectNode(val, key, attrStr, level) {\n  if (attrStr && val.indexOf('<') === -1) {\n    return (\n      this.indentate(level) +\n      '<' +\n      key +\n      attrStr +\n      '>' +\n      val +\n      //+ this.newLine\n      // + this.indentate(level)\n      '</' +\n      key +\n      this.tagEndChar\n    );\n  } else {\n    return (\n      this.indentate(level) +\n      '<' +\n      key +\n      attrStr +\n      this.tagEndChar +\n      val +\n      //+ this.newLine\n      this.indentate(level) +\n      '</' +\n      key +\n      this.tagEndChar\n    );\n  }\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n  if (val !== '') {\n    return this.buildObjectNode(val, key, attrStr, level);\n  } else {\n    return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\n    //+ this.newLine\n  }\n}\n\nfunction buildTextValNode(val, key, attrStr, level) {\n  return (\n    this.indentate(level) +\n    '<' +\n    key +\n    attrStr +\n    '>' +\n    this.options.tagValueProcessor(val) +\n    '</' +\n    key +\n    this.tagEndChar\n  );\n}\n\nfunction buildEmptyTextNode(val, key, attrStr, level) {\n  if (val !== '') {\n    return this.buildTextValNode(val, key, attrStr, level);\n  } else {\n    return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\n  }\n}\n\nfunction indentate(level) {\n  return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name /*, options*/) {\n  if (name.startsWith(this.options.attributeNamePrefix)) {\n    return name.substr(this.attrPrefixLen);\n  } else {\n    return false;\n  }\n}\n\nfunction isCDATA(name) {\n  return name === this.options.cdataTagName;\n}\n\n//formatting\n//indentation\n//\\n after each closing or self closing tag\n\nvar json2xml = Parser;\n\nvar parser = createCommonjsModule(function (module, exports) {\n\n\n\nconst x2xmlnode = xmlstr2xmlnode;\nconst buildOptions = util.buildOptions;\n\n\nexports.parse = function(xmlData, givenOptions = {}, validationOption) {\n  if( validationOption){\n    if(validationOption === true) validationOption = {};\n    \n    const result = validator.validate(xmlData, validationOption);\n    if (result !== true) {\n      throw Error( result.err.msg)\n    }\n  }\n  if(givenOptions.parseTrueNumberOnly \n    && givenOptions.parseNodeValue !== false\n    && !givenOptions.numParseOptions){\n    \n      givenOptions.numParseOptions = {\n        leadingZeros: false,\n      };\n  }\n  let options = buildOptions(givenOptions, x2xmlnode.defaultOptions, x2xmlnode.props);\n\n  const traversableObj = xmlstr2xmlnode.getTraversalObj(xmlData, options);\n  //print(traversableObj, \"  \");\n  return node2json.convertToJson(traversableObj, options);\n};\nexports.convertTonimn = nimndata.convert2nimn;\nexports.getTraversalObj = xmlstr2xmlnode.getTraversalObj;\nexports.convertToJson = node2json.convertToJson;\nexports.convertToJsonString = node2json_str.convertToJsonString;\nexports.validate = validator.validate;\nexports.j2xParser = json2xml;\nexports.parseToNimn = function(xmlData, schema, options) {\n  return exports.convertTonimn(exports.getTraversalObj(xmlData, options), schema, options);\n};\n});\n\nconst parser$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), parser, {\n  'default': parser\n}));\n\nexport { parser$1 as p };\n"],"names":["commonjsGlobal","globalThis","window","global","self","getDefaultExportFromCjs","x","__esModule","Object","prototype","hasOwnProperty","call","createCommonjsModule","fn","basedir","module","path","exports","require","base","Error","commonjsRequire","getAugmentedNamespace","n","a","defineProperty","value","keys","forEach","k","d","getOwnPropertyDescriptor","get","enumerable","hexRegex","numRegex","Number","parseInt","parseFloat","consider","hex","leadingZeros","decimalPoint","eNotation","trimZeros","numStr","indexOf","replace","length","substr","strnum","str","options","assign","trimmedStr","trim","undefined","skipLike","test","match","exec","sign","numTrimmedByZeros","num","search","util","nameStartChar","nameRegexp","regexName","RegExp","isExist","v","isEmptyObject","obj","merge","target","arrayMode","len","i","getValue","buildOptions","defaultOptions","props","newOptions","isTagNameInArrayMode","tagName","parentTagName","isName","string","getAllMatches","regex","matches","allmatches","startIndex","lastIndex","index","push","convertToJson_1","convertToJson","node","jObj","alwaysCreateTextNode","child","attrsMap","val","cdataPositionChar","asArray","tagname","textNodeName","tag","result","node2json","xmlNode","parent","this","addChild","Array","isArray","buildOptions$3","defaultOptions$2","attributeNamePrefix","attrNodeName","ignoreAttributes","ignoreNameSpace","allowBooleanAttributes","parseNodeValue","parseAttributeValue","trimValues","cdataTagName","numParseOptions","tagValueProcessor","attrValueProcessor","attrName","stopNodes","defaultOptions_1","props$2","props_1","processTagValue","parseValue","resolveNameSpace","tags","split","prefix","charAt","shouldParse","newval","attrsRegx","buildAttributesMap","attrStr","attrs","attrCollection","closingIndexForOpeningTag","data","attrBoundary","tagExp","ch","findClosingIndex","xmlData","errMsg","closingIndex","xmlstr2xmlnode","getTraversalObj","xmlObj","currentNode","textData","closeIndex","substring","colonIndex","includes","childNode","separatorIndex","shouldBuildAttributesMap","lastIndexOf","defaultOptions$1","props$1","readPI","start","getErrorObject","getLineNumberForPosition","readCommentAndCDATA","angleBracketsCount","readAttributeStr","startChar","tagClosed","validAttrStrRegxp","validateAttributeString","attrNames","getPositionFromMatch","validateAttrName","validateAmpersand","re","validateNumberAmpersand","count","code","message","lineNumber","err","msg","line","col","lines","validator","tagFound","reachedRoot","tagStartPos","closingTag","attrStrStart","isValid","otg","pop","openPos","afterAmp","JSON","stringify","map","t","char","String","fromCharCode","chars","nilChar","missingChar","nilPremitive","missingPremitive","emptyChar","emptyValue","boundryChar","objStart","arrStart","arrayEnd","charsArr","_e","e_schema","hasValidData","itemSchema","arr_len","arr_i","r","processValue","key","isAppChar","buildOptions$2","nimndata","convert2nimn","buildOptions$1","_cToJsonStr","level","isNaN","node2json_str","convertToJsonString","indentBy","format","supressEmptyNode","Parser","isAttribute","attrPrefixLen","isCDATA","replaceCDATAstr","replaceCDATAarr","processTextOrObjNode","indentate","tagEndChar","newLine","buildTextNode","buildEmptyTextNode","buildObjNode","buildEmptyObjNode","buildTextValNode","buildObjectNode","object","j2x","cdata","join","repeat","name","startsWith","parse","rootNodeName","Date","attr","arrLen","j","item","Ks","L","json2xml","parser","x2xmlnode","givenOptions","validationOption","parseTrueNumberOnly","traversableObj","convertTonimn","validate","j2xParser","parseToNimn","schema","parser$1","freeze","create"],"sourceRoot":""}