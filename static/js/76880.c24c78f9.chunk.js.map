{"version":3,"file":"static/js/76880.c24c78f9.chunk.js","mappings":"skBASA,SAASA,EAASC,EAAOC,GACrB,OAA+B,IAAxBD,EAAME,QAAQD,EACzB,CAEA,IAiKIE,EAvBEC,EAAqB,SAACC,GACxB,GAAKA,EAAL,CAGA,IAAMC,EAAsBD,EAAWE,oBACvC,OAAOC,EAAYF,EAFnB,CAGJ,EAGME,EAAc,CAChBC,IApJQ,CACR,cACA,wBACA,uBACA,YACA,gBACA,oBACA,iBACA,0BACA,WACA,iBACA,eA0IAC,QAxIY,CACZ,iBACA,MACA,8BACA,qBACA,gBACA,kBACA,mBACA,UACA,UACA,iBACA,MACA,kBACA,eACA,YACA,iBACA,SAyHAC,SAvHa,CACb,cACA,gBACA,WACA,YACA,QACA,gBACA,gBACA,cACA,uBACA,kBACA,iBACA,WACA,MACA,UACA,mBAyGAC,MAvGU,CAAC,aAwGXC,SAvGa,CAAC,OAAQ,yBAwGtBC,WAvGe,CAAC,kBAwGhBC,SAtGa,CAAC,2BAuGdC,SAxGa,CAAC,YAyGdC,IAvGQ,CACR,mBACA,gBACA,oBACA,cACA,gBACA,cACA,sBACA,kBACA,uBACA,UACA,YACA,MACA,MACA,QA0FAC,MAxFU,CACV,oBACA,4BACA,4BACA,iBACA,kBACA,cACA,iBACA,+BACA,sBACA,gBACA,kBACA,iBACA,oBACA,mBACA,wBACA,uBACA,wBACA,aACA,gBACA,iBACA,QACA,SACA,kBACA,WACA,eACA,cACA,yBACA,eACA,qBACA,qBACA,qBACA,2BACA,8BACA,kBACA,mBACA,2BACA,eACA,gBACA,qBACA,qBACA,QACA,eACA,sBACA,4BA6CAC,KA3CS,CAAC,uBAAwB,qBAoEtC,SAASC,EAAUC,GACf,IAAIC,EAboBjB,EAgBxB,OAAQgB,EAAKE,eAKT,IAAK,gBACDD,EAAS,UACT,MACJ,IAAK,kBACL,IAAK,eAEDA,EAAS,MACT,MACJ,IAAK,kBACDA,EAAS,WACT,MACJ,IAAK,cACL,IAAK,8BACL,IAAK,kBACDA,EAAS,UACT,MACJ,IAAK,cACDA,EAAS,UACT,MACJ,QAxCoBjB,EAjDN,SAACgB,GACnB,GAAKA,EAAL,CAGA,IAAMG,EAAgBH,EAAKd,oBAC3B,OAAOkB,OAAOC,KAAKlB,GAAamB,MAAK,SAACC,GAElC,OADwBpB,EAAYoB,GACbC,MAAK,SAACC,GAAC,OAAKA,EAAEvB,sBAAwBiB,CAAa,GAC9E,GALA,CAMJ,CAkFwCO,CAAcV,GAA1CC,EAzCU,CACdJ,MAAO,UACPF,SAAU,YAEGX,IAAeA,EAuChC,OAAOiB,CACX,CAOA,SAASU,EAAeV,GACpB,IAAIW,EAGJ,OAAQX,EAAOC,eACX,IAAK,UAEDU,GADAA,EAAQ7B,EAAmB,UACb8B,OAAO,CACjB,cACA,8BACA,oBAEJ,MACJ,IAAK,WACDD,EAAQ,GAAH,eACE7B,EAAmB,cAAW,OAC9BA,EAAmB,cAE1B,MACJ,IAAK,UAKD6B,GAJAA,EAAQ7B,EAAmBkB,EAAOC,eAAeY,QAAO,SAACd,GAAI,MAAc,gCAATA,GACrD,oBAATA,GACS,iBAATA,GACS,oBAATA,CAA0B,KAChBa,OAAO,iBACrB,MACJ,IAAK,MAEDD,GADAA,EAAQ7B,EAAmBkB,EAAOC,eAAeY,QAAO,SAACd,GAAI,MAAc,kBAATA,CAAwB,KAC5Ea,OAAO,CAAC,kBAAmB,iBACzC,MACJ,IAAK,WAEDD,GADAA,EAAQ7B,EAAmBkB,EAAOC,eAAeY,QAAO,SAACd,GAAI,MAAc,gBAATA,GAAmC,oBAATA,CAA0B,KACxGa,OAAO,mBACrB,MACJ,IAAK,UACDD,EAAQ,CAAC,eACT,MACJ,QACIA,EAAQ7B,EAAmBkB,EAAOC,eAE1C,OAAOU,CACX,EAtGA,SAAW9B,GACPA,EAAiC,gBAAI,qCACrCA,EAAiC,gBAAI,4BACrCA,EAAiC,gBAAI,mBACrCA,EAA2B,UAAI,aAC/BA,EAAsB,KAAI,MAC7B,CAND,CAMGA,IAAoBA,EAAkB,CAAC,IAkH1C,IAmKIiC,EAnKEC,EAAqB,SAACC,GACxB,IAAIC,EACEC,EAAOF,EAAKG,OACZC,GAAoBC,EAAAA,EAAAA,GAAOH,GAE3BI,GAAyC,QAA1BL,EAAKD,EAAKO,kBAA+B,IAAPN,OAAgB,EAASA,EAAGO,YAE9EJ,EAAoB,YAASK,GAC5BD,EAAW,CACbE,SAAU,KACVJ,WAAAA,GAEJ,GAAmB,SAAfA,GAAyBF,EAAmB,CAC5C,IAAMD,GAASQ,EAAAA,EAAAA,GAAaT,GACtBU,GAASC,EAAAA,EAAAA,GAAgBV,GAC/BK,EAASI,OAAS,CAACA,EAAOE,EAAGF,EAAOG,GACpCP,EAASE,SAAWvB,OAAO6B,OAAO7B,OAAO6B,OAAO,CAAC,GAAGC,EAAAA,EAAAA,GAAgBd,IAAU,CAAEpB,KAAM,YACtFyB,EAASU,iBAAmBV,EAASE,SAASQ,gBAClD,CACA,OAAOV,CACX,EAUMW,EAAW,SAACC,GACd,OAAOA,GAAkBA,EAAeD,QAC5C,EASME,EAAsB,SAACrB,EAAMoB,GAC/B,QAASpB,GAAwB,WAAhBA,EAAKsB,SAAwBH,EAASC,EAC3D,EASMG,EAAe,SAACvB,EAAMoB,GAAc,OAAMD,EAASC,IACrC,WAAhBpB,EAAKsB,QACS,QAAdtB,EAAKjB,MACLiB,EAAKwB,MAAQ,GAAO,EASlBC,EAAoB,SAAC1C,EAAM2C,EAAYC,GAEzC,IAAIC,EAAaC,EAAe9C,EAAM2C,EAAYC,IAC9CG,EAAyB/C,EAAM2C,EAAYC,GAC/C,IAAKC,EAAY,CACb,IAAM5C,EAASF,EAAUC,GAUrBgD,EAAO,WACI,aAAX/C,EAEA+C,EAAO,oBAEFC,EAAWjD,EAAM4C,GAItBI,EAAO,SAlByB,CAChC,MACA,UACA,WACA,MACA,WACA,WAciCnE,QAAQoB,IAAW,IAEpD+C,EAAO,IAAH,OAAO/C,EAAM,MAErB4C,EAAa,GAAH,OAAMG,EAAI,YAAIL,EAC5B,CACA,OAAOE,CACX,EAOMI,EAAa,SAACjD,GAAI,IAAE4C,EAAe,UAAH,6CAAG,GAAE,MAAK,CAAC,WAAY,aAAalE,SAASsB,IAAS4C,EAAalE,SAAS,UAAU,EACtHoE,EAAiB,SAAC9C,EAAM2C,EAAYC,GACtC,IAAIM,EAgBJ,MAfa,aAATlD,EAKIkD,GAFkB,OAAjBN,QAA0C,IAAjBA,OAA0B,EAASA,EAAa/D,QAAQ,cAAgB,EAEzF,YAAH,OAAe8D,EAAU,UAGtB,cAAH,OAAiBA,EAAU,UAGvB,4BAAT3C,IACa,OAAjB4C,QAA0C,IAAjBA,OAA0B,EAASA,EAAa/D,QAAQ,yBAA2B,IAC7GqE,EAAS,cAAH,OAAiBP,EAAU,WAE9BO,CACX,EACMH,EAA2B,SAAC/C,EAAM2C,EAAYC,GAChD,GAAc,mBAAT5C,IACiB,OAAjB4C,QAA0C,IAAjBA,OAA0B,EAASA,EAAa/D,QAAQ,2BAA6B,GACtG,4BAATmB,EACA,MAAO,0BAAP,OAAiC2C,EAAU,SAEnD,EAOA,SAASQ,EAAgBR,GAUrB,MARsB,CAClBS,gBAAiB,6DACjBC,WAAY,iDACZC,QAAS,8CACTC,WAAY,iDACZC,wBAAyB,iDACzBC,oBAAqB,qBAEJd,EACzB,CAQA,SAASe,EAAqBC,EAAUhB,GACpC,IAAMK,EAAOG,EAAgBR,GAC7B,OAAOK,IAAQY,EAAAA,EAAAA,GAAQD,EAAUX,EACrC,CAuBA,SAASa,EAAmBC,GAExB,IAAIC,EACAC,EACJ,GAHAF,EAAY,GAAH,OAAMA,GAGX,UAAUG,KAAKH,GAEfC,EAAO,IAAIG,MAAMJ,EAAW,EAAG,GAC/BE,EAAYjD,EAAcoD,UAEzB,GAAI,kBAAkBF,KAAKH,GAAY,CAExC,IAAMM,EAAQN,EAAUO,MAAM,KAC9BN,EAAO,IAAIG,MAAME,EAAM,IAAKA,EAAM,GAAK,EAAG,GAC1CJ,EAAYjD,EAAcuD,KAC9B,MACK,GAAI,0BAA0BL,KAAKH,GAAY,CAEhD,IAAMM,EAAQN,EAAUO,MAAM,KAC9BN,EAAO,IAAIG,MAAME,EAAM,IAAKA,EAAM,GAAK,GAAIA,EAAM,IACjDJ,EAAYjD,EAAcwD,GAC9B,MACUC,OAAOC,MAAMP,KAAKQ,MAAMZ,MAE9BC,EAAO,IAAIG,KAAKJ,GAChBE,EAAYF,EAAUpF,SAAS,KACzBqC,EAAc4D,KACd5D,EAAcwD,KAExB,OAAOR,GAAQC,GAAa,CAAED,KAAAA,EAAMC,UAAAA,EACxC,EA/CA,SAAWjD,GACPA,EAAoB,KAAI,OACxBA,EAAqB,MAAI,QACzBA,EAAmB,IAAI,MACvBA,EAAoB,KAAI,MAC3B,CALD,CAKGA,IAAkBA,EAAgB,CAAC,IAuDtC,IAAM6D,EAA0B,SAAC3D,GAC7B,IAAMkB,EAAmBlB,EAAKkB,iBAC9B,IAAKA,GAAgD,kBAArBA,EAE5B,OAAOA,EAIX,IACM0C,EAAOC,SADkB3C,EAAmB,GACJ,IAC9C,OAAOsC,MAAMI,GAGL,KAEA,CAAEA,KAAAA,EACd,EAYME,EAAyB,SAAC9D,EAAM0C,EAAUtB,GAC5C,IAAM2C,EAAeC,EAAoBtB,GACzC,OAAQqB,GACJA,EAAapF,KAAI,SAACsF,GAAQ,MAAM,CAC5BC,KAAMD,EAASE,OACfC,IAAKC,EAAyBJ,EAAUjE,EAAMoB,GAC9CkD,aAAcC,EAAmBN,EAAUjE,GAC9C,GACT,EAUMgE,EAAsB,SAACtB,GACzB,IAAMqB,EAAe,GAYrB,OAPAS,GAAY7B,EAAAA,EAAAA,GAAQD,EAAU,sBAAwB,IAAI+B,SAAQ,SAACC,GAC/DF,EAAYE,EAASC,aAAe,IAAIF,SAAQ,SAACE,GAC7CH,EAAYG,EAAYC,WAAa,IAAIH,SAAQ,SAACG,GAC9Cb,EAAac,KAAKD,EACtB,GACJ,GACJ,IACOb,EAAae,OAASf,EAAe,IAChD,EAUMS,EAAc,SAACO,GACjB,OAAOC,MAAMC,QAAQF,GAAiBA,EAAgB,CAACA,EAC3D,EAWMR,EAAqB,SAACN,EAAUjE,GAClC,IAAMkF,EAAalF,EAAKoE,MAAOe,EAAAA,EAAAA,GAAgBnF,EAAKoE,KACpD,OAAQc,GAAcjB,EAASmB,SAAWnB,EAASmB,QAAQ3H,SAASyH,EACxE,EAaMb,EAA2B,SAACJ,EAAUjE,EAAMoB,GAC9C,IAAIiE,EAASpB,EAASmB,QAChBE,GAAQ3C,EAAAA,EAAAA,GAAQvB,EAAgB,wBACtC,GAAIkE,GAASf,EAAmBN,EAAUjE,GAAO,CAC7C,IAAMuF,EAAS,IAAIC,IAAIvB,EAASmB,SAC1BK,EAAS,IAAIC,gBAAgBH,EAAOI,QAC1CF,EAAOG,IAAI,QAASN,GACpBC,EAAOI,OAASF,EAAOI,WACvBR,EAASE,EAAOM,UACpB,CACA,OAAOR,CACX,EAkBMS,EAAkB,SAAC9F,EAAM+F,EAAkBC,GAC7C,IAAMC,GAAa5F,EAAAA,EAAAA,GAAOL,EAAKG,QAAUH,EAAKG,YAASM,EACjDyF,GAA8B7F,EAAAA,EAAAA,GAA4B,OAArB0F,QAAkD,IAArBA,OAA8B,EAASA,EAAiBI,aAC1HJ,EAAiBI,iBACjB1F,EACA2F,EAAiE,QAAnDzD,EAAAA,EAAAA,GAAQqD,EAAO,iCAC7BK,EAAAA,EAAAA,GAAaL,EAAM7F,aACnBM,EACN,OAAOwF,GAAcC,GAA+BE,CACxD,EAeME,EAAsB,SAAC5D,EAAUX,GACnC,IAAMwE,GAAc5D,EAAAA,EAAAA,GAAQD,EAAUX,IAAS,CAAC,EAChD,EAAiCiD,MAAMC,QAAQsB,GACzCA,EAAY,GACZA,EACN,MAAO,CAAEC,eAHQ,EAATC,UAG4BC,iBAHR,EAATC,UAIvB,EAQMC,EAAe,SAAC5G,EAAM6G,GAAS,OAAK7G,EAAK8G,QAAwB,OAAdD,QAAoC,IAAdA,OAAuB,EAASA,EAAUC,MAAM,EAezHC,EAAmB,SAAC/G,EAAM0C,EAAUsE,EAAKH,GAC3C,IAAMxB,EAAS,CACX4B,WAAYpJ,EAAgBqJ,KAC5BC,mBAAoBtJ,EAAgBqJ,MAElCE,EAAkBd,EAAoB5D,EAAU,+CAChD2E,EAAkBf,EAAoB5D,EAAU,6BAChD4E,EAAkBhB,EAAoB5D,EAAU,sBAEhD6E,GAAgB5E,EAAAA,EAAAA,GAAQkE,EAAW,YACrCO,EAAgBZ,gBAChBnB,EAAOnB,KAAOkD,EAAgBZ,eAC9BnB,EAAO4B,WAAapJ,EAAgB2J,iBAE/BH,EAAgBb,gBACrBnB,EAAOnB,KAAOmD,EAAgBb,eAC9BnB,EAAO4B,WAAapJ,EAAgB4J,iBAE/BH,EAAgBd,gBACrBnB,EAAOnB,KAAOoD,EAAgBd,eAC9BnB,EAAO4B,WAAapJ,EAAgB6J,iBAE/BH,IACLlC,EAAOnB,KAAOqD,EACdlC,EAAOsC,SAAWd,EAAUc,SAC5BtC,EAAO4B,WAAapJ,EAAgB+J,WAGxC,IAAMC,GAAUlF,EAAAA,EAAAA,GAAQqE,EAAK,QAsB7B,OArBII,EAAgBV,kBAChBrB,EAAOyC,aAAeV,EAAgBV,iBACtCrB,EAAO8B,mBAAqBtJ,EAAgB2J,iBAEvCH,EAAgBX,kBACrBrB,EAAOyC,aAAeT,EAAgBX,iBACtCrB,EAAO8B,mBAAqBtJ,EAAgB4J,iBAEvCH,EAAgBZ,kBACrBrB,EAAOyC,aAAeR,EAAgBZ,iBACtCrB,EAAO8B,mBAAqBtJ,EAAgB6J,iBAEvCG,IACLxC,EAAOyC,aAAeD,EACtBxC,EAAOyB,MAAQF,EAAa5G,EAAM6G,GAClCxB,EAAO8B,mBAAqBtJ,EAAgB+J,WAGhDvC,EAAO0C,WACH1C,EAAO8B,qBAAuBtJ,EAAgBqJ,MAC1B,WAAhBlH,EAAKsB,OACN+D,CACX,C,uEC3uBI2C,EAAe,IAAIC,OAAO,kCAI9B,SAAS9C,EAAgBf,GACrB,IAAI8D,EAAQ9D,EAAI8D,MAAMF,GACtB,OAAIE,EACOA,EAAM,GAMrB,SAA0B9D,GACtB,IAAI+D,EAAW/D,EAAIhB,MAAM,KAAK,GAC9B,OAAOgF,EAAAA,EAAAA,GAASD,EACpB,CANeE,CAAiBjE,EAEhC,C","sources":["../node_modules/@esri/hub-components/dist/esm/_internal-89d3dc92.js","../node_modules/@esri/hub-components/dist/esm/helpers-a80c0291.js"],"sourcesContent":["import { e as extentToPolygon, i as isBBox, a as extentToBBox, g as getExtentCenter, b as bBoxToExtent } from './extent-0f42acfc.js';\nimport { g as getProp } from './get-prop-d82e4fa6.js';\nimport { p as parseServiceUrl } from './helpers-a80c0291.js';\n\n/**\n * Checks whether a value exists in the given array\n * @param array The array\n * @param val The value\n */\nfunction includes(array, val) {\n    return array.indexOf(val) !== -1;\n}\n\nconst app = [\n    \"Application\",\n    \"City Engine Web Scene\",\n    \"CityEngine Web Scene\",\n    \"Dashboard\",\n    \"Insights Page\",\n    \"Insights Workbook\",\n    \"Operation View\",\n    \"Web Mapping Application\",\n    \"StoryMap\",\n    \"Web Experience\",\n    \"Urban Model\",\n];\nconst dataset = [\n    \"CSV Collection\",\n    \"CSV\",\n    \"Feature Collection Template\",\n    \"Feature Collection\",\n    \"Feature Layer\",\n    \"Feature Service\",\n    \"File Geodatabase\",\n    \"GeoJSON\",\n    \"GeoJson\",\n    \"KML Collection\",\n    \"KML\",\n    \"Microsoft Excel\",\n    \"Raster Layer\",\n    \"Shapefile\",\n    \"Stream Service\",\n    \"Table\",\n];\nconst document = [\n    \"CAD Drawing\",\n    \"Document Link\",\n    \"Hub Page\",\n    \"Site Page\",\n    \"Image\",\n    \"iWork Keynote\",\n    \"iWork Numbers\",\n    \"iWork Pages\",\n    \"Microsoft Powerpoint\",\n    \"Microsoft Visio\",\n    \"Microsoft Word\",\n    \"Notebook\",\n    \"PDF\",\n    \"Pro Map\",\n    \"Report Template\",\n];\nconst event = [\"Hub Event\"];\nconst feedback = [\"Form\", \"Quick Capture Project\"];\nconst initiative = [\"Hub Initiative\"];\nconst solution = [\"Solution\"];\nconst template = [\"Hub Initiative Template\"];\nconst map = [\n    \"Image Collection\",\n    \"Image Service\",\n    \"Map Service Layer\",\n    \"Map Service\",\n    \"Scene Service\",\n    \"Scene Layer\",\n    \"Vector Tile Service\",\n    \"Web Map Service\",\n    \"Web Map Tile Service\",\n    \"Web Map\",\n    \"Web Scene\",\n    \"WFS\",\n    \"WMS\",\n    \"WMTS\",\n];\nconst other = [\n    \"360 VR Experience\",\n    \"AppBuilder Widget Package\",\n    \"Application Configuration\",\n    \"ArcPad Package\",\n    \"Code Attachment\",\n    \"Code Sample\",\n    \"Desktop Add In\",\n    \"Desktop Application Template\",\n    \"Desktop Application\",\n    \"Desktop Style\",\n    \"Explorer Add In\",\n    \"Explorer Layer\",\n    \"Geocoding Service\",\n    \"Geometry Service\",\n    \"Geoprocessing Package\",\n    \"Geoprocessing Sample\",\n    \"Geoprocessing Service\",\n    \"Layer File\",\n    \"Layer Package\",\n    \"Layer Template\",\n    \"Layer\",\n    \"Layout\",\n    \"Locator Package\",\n    \"Map Area\",\n    \"Map Document\",\n    \"Map Package\",\n    \"Map Service Definition\",\n    \"Map Template\",\n    \"Mobile Application\",\n    \"Mobile Map Package\",\n    \"Native Application\",\n    \"Network Analysis Service\",\n    \"Operations Dashboard Add In\",\n    \"Project Package\",\n    \"Project Template\",\n    \"Raster Function Template\",\n    \"Rule Package\",\n    \"Scene Package\",\n    \"Service Definition\",\n    \"SQLite Geodatabase\",\n    \"Style\",\n    \"Tile Package\",\n    \"Vector Tile Package\",\n    \"Workflow Manager Package\",\n];\nconst site = [\"Hub Site Application\", \"Site Application\"];\n/**\n * Get the Hub collection for a given item type\n * @param itemType The ArcGIS [item type](https://developers.arcgis.com/rest/users-groups-and-items/items-and-item-types.htm).\n * @returns the Hub collection of a given item type.\n * @private\n */\nconst getCollection = (type) => {\n    if (!type) {\n        return;\n    }\n    const lowerCaseType = type.toLocaleLowerCase();\n    return Object.keys(collections).find((key) => {\n        const collectionTypes = collections[key];\n        return collectionTypes.some((t) => t.toLocaleLowerCase() === lowerCaseType);\n    });\n};\n/**\n * The converse of getCollection, returns associated types of provided collection\n * @param collection The Hub collection\n * @returns An array of types or undefined if collection is not found\n * @private\n */\nconst getCollectionTypes = (collection) => {\n    if (!collection) {\n        return;\n    }\n    const lowerCaseCollection = collection.toLocaleLowerCase();\n    return collections[lowerCaseCollection];\n};\n// TODO: remove this when we remove the deprecated categories\n// and then move the above arrays and getCollection() logic to get-family\nconst collections = {\n    app,\n    dataset,\n    document,\n    event,\n    feedback,\n    initiative,\n    template,\n    solution,\n    map,\n    other,\n    site,\n};\n\nvar PublisherSource;\n(function (PublisherSource) {\n    PublisherSource[\"CitationContact\"] = \"metadata.resource.citation.contact\";\n    PublisherSource[\"ResourceContact\"] = \"metadata.resource.contact\";\n    PublisherSource[\"MetadataContact\"] = \"metadata.contact\";\n    PublisherSource[\"ItemOwner\"] = \"item.owner\";\n    PublisherSource[\"None\"] = \"none\";\n})(PublisherSource || (PublisherSource = {}));\n\n// private helper functions\nfunction collectionToFamily(collection) {\n    const overrides = {\n        other: \"content\",\n        solution: \"template\",\n    };\n    return overrides[collection] || collection;\n}\n/**\n * return the Hub family given an item's type\n * @param type item type\n * @returns Hub family\n */\nfunction getFamily(type) {\n    let family;\n    // override default behavior for the rows that are highlighted in yellow here:\n    // https://esriis.sharepoint.com/:x:/r/sites/ArcGISHub/_layouts/15/Doc.aspx?sourcedoc=%7BADA1C9DC-4F6C-4DE4-92C6-693EF9571CFA%7D&file=Hub%20Routes.xlsx&nav=MTBfe0VENEREQzI4LUZFMDctNEI0Ri04NjcyLThCQUE2MTA0MEZGRn1fezIwMTIwMEJFLTA4MEQtNEExRC05QzA4LTE5MTAzOUQwMEE1RH0&action=default&mobileredirect=true&cid=df1c874b-c367-4cea-bc13-7bebfad3f2ac\n    switch (type.toLowerCase()) {\n        // NOTE: we really want to put tiled image services in the maps family\n        // but we would need the typekeywords to differentiate them\n        // for now send them to the maps route here:\n        // https://github.com/ArcGIS/opendata-ui/blob/cdc0dac6b7e8c43afaa60ae219393a7d3aaa7433/packages/ember-arcgis-hub-components/addon/utils/content-routes.js#L39-L44\n        case \"image service\":\n            family = \"dataset\";\n            break;\n        case \"feature service\":\n        case \"raster layer\":\n            // TODO: check if feature service has > 1 layer first?\n            family = \"map\";\n            break;\n        case \"microsoft excel\":\n            family = \"document\";\n            break;\n        case \"cad drawing\":\n        case \"feature collection template\":\n        case \"report template\":\n            family = \"content\";\n            break;\n        case \"hub project\":\n            family = \"project\";\n            break;\n        default:\n            // by default derive from collection\n            family = collectionToFamily(getCollection(type));\n    }\n    return family;\n}\n/**\n * return the types associated with a provided Hub Family\n * Overrides are provided to match getFamily implementation\n * @param type item type\n * @returns Hub family\n */\nfunction getFamilyTypes(family) {\n    let types;\n    // override default behavior for the rows that are highlighted in yellow here:\n    // https://esriis.sharepoint.com/:x:/r/sites/ArcGISHub/_layouts/15/Doc.aspx?sourcedoc=%7BADA1C9DC-4F6C-4DE4-92C6-693EF9571CFA%7D&file=Hub%20Routes.xlsx&nav=MTBfe0VENEREQzI4LUZFMDctNEI0Ri04NjcyLThCQUE2MTA0MEZGRn1fezIwMTIwMEJFLTA4MEQtNEExRC05QzA4LTE5MTAzOUQwMEE1RH0&action=default&mobileredirect=true&cid=df1c874b-c367-4cea-bc13-7bebfad3f2ac\n    switch (family.toLowerCase()) {\n        case \"content\":\n            types = getCollectionTypes(\"other\");\n            types = types.concat([\n                \"CAD Drawing\",\n                \"Feature Collection Template\",\n                \"Report Template\",\n            ]);\n            break;\n        case \"template\":\n            types = [\n                ...getCollectionTypes(\"template\"),\n                ...getCollectionTypes(\"solution\"),\n            ];\n            break;\n        case \"dataset\":\n            types = getCollectionTypes(family.toLowerCase()).filter((type) => type !== \"Feature Collection Template\" &&\n                type !== \"Feature Service\" &&\n                type !== \"Raster Layer\" &&\n                type !== \"Microsoft Excel\");\n            types = types.concat(\"Image Service\");\n            break;\n        case \"map\":\n            types = getCollectionTypes(family.toLowerCase()).filter((type) => type !== \"Image Service\");\n            types = types.concat([\"Feature Service\", \"Raster Layer\"]);\n            break;\n        case \"document\":\n            types = getCollectionTypes(family.toLowerCase()).filter((type) => type !== \"CAD Drawing\" && type !== \"Report Template\");\n            types = types.concat(\"Microsoft Excel\");\n            break;\n        case \"project\":\n            types = [\"Hub Project\"];\n            break;\n        default:\n            types = getCollectionTypes(family.toLowerCase());\n    }\n    return types;\n}\n\n/**\n * Use this module for functions that do not need to be used by consumers (yet),\n * but may be shared between hub.js modules, and/or need to be tested\n * to get 100% coverage w/o writing cumbersome tests of higher level functions.\n *\n * Consuming will not be able to import these functions.\n *\n * It's probably a good pattern to add functions here first and then\n * move them to index.ts only when they are needed by a consumer.\n */\n/**\n * get a content's boundary based on the item's boundary property\n * @param item\n * @returns\n * @private\n */\nconst getContentBoundary = (item) => {\n    var _a;\n    const bBox = item.extent;\n    const isValidItemExtent = isBBox(bBox);\n    // user specified provenance is stored in item.properties\n    const provenance = ((_a = item.properties) === null || _a === void 0 ? void 0 : _a.boundary) ||\n        // but we default to item if the item has an extent\n        (isValidItemExtent ? \"item\" : undefined);\n    const boundary = {\n        geometry: null,\n        provenance,\n    };\n    if (provenance === \"item\" && isValidItemExtent) {\n        const extent = bBoxToExtent(bBox);\n        const center = getExtentCenter(extent);\n        boundary.center = [center.x, center.y];\n        boundary.geometry = Object.assign(Object.assign({}, extentToPolygon(extent)), { type: \"polygon\" });\n        boundary.spatialReference = boundary.geometry.spatialReference;\n    }\n    return boundary;\n};\n/**\n * Determine if we are in an enterprise environment\n * NOTE: when no request options are provided, the underlying\n * request functions assume that we are online in production\n * so we only want use enterprise logic if isPortal is explicitly defined\n * @param requestOptions\n * @returns\n * @private\n */\nconst isPortal = (requestOptions) => {\n    return requestOptions && requestOptions.isPortal;\n};\n/**\n * Determine if we can use the Hub API for an item, i.e.\n * the item is public and we are not in an enterprise environment\n * @param item\n * @param requestOptions\n * @returns\n * @private\n */\nconst canUseHubApiForItem = (item, requestOptions) => {\n    return !!item && item.access === \"public\" && !isPortal(requestOptions);\n};\n/**\n * Returns whether or not an item is a proxied csv\n *\n * @param item\n * @param requestOptions Hub Request Options (including whether we're in portal)\n * @returns\n * @private\n */\nconst isProxiedCSV = (item, requestOptions) => !isPortal(requestOptions) &&\n    item.access === \"public\" &&\n    item.type === \"CSV\" &&\n    item.size <= 5000000;\n/**\n * Get the relative URL to use for the item in a hub site\n * @param type\n * @param identifier\n * @param typeKeywords\n * @returns\n * @private\n */\nconst getHubRelativeUrl = (type, identifier, typeKeywords) => {\n    // solution types have their own logic\n    let contentUrl = getSolutionUrl(type, identifier, typeKeywords) ||\n        getInitiativeTemplateUrl(type, identifier, typeKeywords);\n    if (!contentUrl) {\n        const family = getFamily(type);\n        const familiesWithPluralizedRoute = [\n            \"app\",\n            \"dataset\",\n            \"document\",\n            \"map\",\n            \"template\",\n            \"project\",\n        ];\n        // default to the catchall content route\n        let path = \"/content\";\n        if (family === \"feedback\") {\n            // the exception\n            path = \"/feedback/surveys\";\n        }\n        else if (isPageType(type, typeKeywords)) {\n            // pages are in the document family,\n            // but instead of showing the page's metadata on /documents/about\n            // but we render the page on the pages route\n            path = \"/pages\";\n        }\n        else if (familiesWithPluralizedRoute.indexOf(family) > -1) {\n            // the rule: route name is plural of family name\n            path = `/${family}s`;\n        }\n        contentUrl = `${path}/${identifier}`;\n    }\n    return contentUrl;\n};\n/**\n * Is this content type a page?\n * @param type\n * @returns\n * @private\n */\nconst isPageType = (type, typeKeywords = []) => [\"Hub Page\", \"Site Page\"].includes(type) || typeKeywords.includes(\"hubPage\");\nconst getSolutionUrl = (type, identifier, typeKeywords) => {\n    let hubUrl;\n    if (type === \"Solution\") {\n        // solution types are now in the Template family\n        // we send all except the deployed solution items to the route for initiative templates\n        if ((typeKeywords === null || typeKeywords === void 0 ? void 0 : typeKeywords.indexOf(\"Deployed\")) > -1) {\n            // deployed solutions go to the generic content route\n            hubUrl = `/content/${identifier}/about`;\n        }\n        else {\n            hubUrl = `/templates/${identifier}/about`;\n        }\n    }\n    else if (type === \"Web Mapping Application\" &&\n        (typeKeywords === null || typeKeywords === void 0 ? void 0 : typeKeywords.indexOf(\"hubSolutionTemplate\")) > -1) {\n        hubUrl = `/templates/${identifier}/about`;\n    }\n    return hubUrl;\n};\nconst getInitiativeTemplateUrl = (type, identifier, typeKeywords) => {\n    if ((type === \"Hub Initiative\" &&\n        (typeKeywords === null || typeKeywords === void 0 ? void 0 : typeKeywords.indexOf(\"hubInitiativeTemplate\")) > -1) ||\n        type === \"Hub Initiative Template\") {\n        return `/initiatives/templates/${identifier}/about`;\n    }\n};\n/**\n * Get the path to a well known metadata value\n * @param identifier identifier for well known metadata value\n * @returns path to be used like get(metadata, path)\n * @private\n */\nfunction getMetadataPath(identifier) {\n    // NOTE: i have verified that this will work regardless of the \"Metadata Style\" set on the org\n    const metadataPaths = {\n        updateFrequency: \"metadata.dataIdInfo.resMaint.maintFreq.MaintFreqCd.@_value\",\n        reviseDate: \"metadata.dataIdInfo.idCitation.date.reviseDate\",\n        pubDate: \"metadata.dataIdInfo.idCitation.date.pubDate\",\n        createDate: \"metadata.dataIdInfo.idCitation.date.createDate\",\n        metadataUpdateFrequency: \"metadata.mdMaint.maintFreq.MaintFreqCd.@_value\",\n        metadataUpdatedDate: \"metadata.mdDateSt\",\n    };\n    return metadataPaths[identifier];\n}\n/**\n * Get a well known value from metadata\n * @param metadata\n * @param identifier identifier for well known metadata value\n * @returns\n * @private\n */\nfunction getValueFromMetadata(metadata, identifier) {\n    const path = getMetadataPath(identifier);\n    return path && getProp(metadata, path);\n}\n/**\n * Date precisions\n */\nvar DatePrecision;\n(function (DatePrecision) {\n    DatePrecision[\"Year\"] = \"year\";\n    DatePrecision[\"Month\"] = \"month\";\n    DatePrecision[\"Day\"] = \"day\";\n    DatePrecision[\"Time\"] = \"time\";\n})(DatePrecision || (DatePrecision = {}));\n/**\n * Parses an ISO8601 date string into a date and a precision.\n * This is because a) if somone entered 2018, we want to respect that and not treat it as the same as 2018-01-01\n * and b) you cannot naively call new Date with an ISO 8601 string that does not include time information\n * For example, when I, here in mountain time, do new Date('2018').getFullYear() I get \"2017\".\n * This is because when you do not provide time or timezone info, UTC is assumed, so new Date('2018') is 2018-01-01T00:00:00 in UTC\n * which is actually 7 hours earlier here in mountain time.\n *\n * @param {string} isoString\n * @return { date: Date, precision: DatePrecision }\n * @private\n */\nfunction parseISODateString(isoString) {\n    isoString = `${isoString}`;\n    let date;\n    let precision;\n    if (/^\\d{4}$/.test(isoString)) {\n        // yyyy\n        date = new Date(+isoString, 0, 1);\n        precision = DatePrecision.Year;\n    }\n    else if (/^\\d{4}-\\d{1,2}$/.test(isoString)) {\n        // yyyy-mm\n        const parts = isoString.split(\"-\");\n        date = new Date(+parts[0], +parts[1] - 1, 1);\n        precision = DatePrecision.Month;\n    }\n    else if (/^\\d{4}-\\d{1,2}-\\d{1,2}$/.test(isoString)) {\n        // yyyy-mm-dd\n        const parts = isoString.split(\"-\");\n        date = new Date(+parts[0], +parts[1] - 1, +parts[2]);\n        precision = DatePrecision.Day;\n    }\n    else if (!Number.isNaN(Date.parse(isoString))) {\n        // any other string parsable to a valid date\n        date = new Date(isoString);\n        precision = isoString.includes(\"T\")\n            ? DatePrecision.Time\n            : DatePrecision.Day;\n    }\n    return date && precision && { date, precision };\n}\n// NOTE: IItem has spatialRefernce: ISpatialReference, but\n// the portal REST API returns spatialReference as as string\n// that is always either WKID like \"102100\" or the name of a\n// WKT like \"NAD_1983_HARN_StatePlane_Hawaii_3_FIPS_5103_Feet\".\n// We only coerce WKIDs into a ISpatialReference objects since we\n// can't easily lookup a complete WKT.\n/**\n * Get the spatial reference as an object for an item\n * @param item\n * @returns spatial reference object\n * @private\n */\nconst getItemSpatialReference = (item) => {\n    const spatialReference = item.spatialReference;\n    if (!spatialReference || typeof spatialReference === \"object\") {\n        // no need to try and transform this into an ISpatialReference\n        return spatialReference;\n    }\n    // otherwise it _should_ be a string (if coming form the REST API)\n    // but we force it in case it was set to a number somewhere outside of TS\n    const spatialReferenceString = spatialReference + \"\";\n    const wkid = parseInt(spatialReferenceString, 10);\n    return isNaN(wkid)\n        ? // It looks like the portal api returns the name of a WKT, but we'd\n            // need to perform a lookup to get the full WKT. Return null for now.\n            null\n        : //\n            { wkid };\n};\n/**\n * Extracts additional resources from the provided metadata\n * and transforms them into a hub-friendly format.\n *\n * Returns null if no resources are available\n *\n * @param item\n * @param metadata formal metadata\n * @returns\n * @private\n */\nconst getAdditionalResources = (item, metadata, requestOptions) => {\n    const rawResources = extractRawResources(metadata);\n    return (rawResources &&\n        rawResources.map((resource) => ({\n            name: resource.orName,\n            url: getAdditionalResourceUrl(resource, item, requestOptions),\n            isDataSource: isDataSourceOfItem(resource, item),\n        })));\n};\n/**\n * @private\n *\n * Extracts additional resources from formal item metadata.\n * If none are available, null is returned.\n *\n * @param metadata the formal item metadata\n * @returns an array of all additional resources, or null\n */\nconst extractRawResources = (metadata) => {\n    const rawResources = [];\n    // The property path to additional resources should be fairly simple.\n    // In many cases, it's just `metadata.metadata.distInfo.distTranOps.onLineSrc`.\n    // However, since `distInfo`, `distTranOps` and `onLineSrc` can be either\n    // Objects OR Arrays, we have to do all this looping.\n    castToArray(getProp(metadata, \"metadata.distInfo\") || []).forEach((distInfo) => {\n        castToArray(distInfo.distTranOps || []).forEach((distTranOps) => {\n            castToArray(distTranOps.onLineSrc || []).forEach((onLineSrc) => {\n                rawResources.push(onLineSrc);\n            });\n        });\n    });\n    return rawResources.length ? rawResources : null;\n};\n/**\n * @private\n *\n * Arrays are returned as-is.\n * Objects are wrapped into a 1 element array.\n *\n * @param objectOrArray\n * @returns the casted array\n */\nconst castToArray = (objectOrArray) => {\n    return Array.isArray(objectOrArray) ? objectOrArray : [objectOrArray];\n};\n/**\n * Determines whether a raw additional resource (i.e. extracted out of formal\n * metadata with no transformation) references the underlying service that backs\n * the item.\n *\n * @param resource raw additional resource of an item\n * @param item\n * @returns\n * @private\n */\nconst isDataSourceOfItem = (resource, item) => {\n    const serviceUrl = item.url && parseServiceUrl(item.url);\n    return (serviceUrl && resource.linkage && resource.linkage.includes(serviceUrl));\n};\n/**\n * Returns the url for an additional resource.\n *\n * Automatically appends auth token if token is available\n * and resource points to the backing service of an item.\n *\n * @param resource raw additional resource of an item\n * @param item\n * @param requestOptions IHubRequestOptions, including authentication\n * @returns\n * @private\n */\nconst getAdditionalResourceUrl = (resource, item, requestOptions) => {\n    let result = resource.linkage;\n    const token = getProp(requestOptions, \"authentication.token\");\n    if (token && isDataSourceOfItem(resource, item)) {\n        const resUrl = new URL(resource.linkage);\n        const params = new URLSearchParams(resUrl.search);\n        params.set(\"token\", token);\n        resUrl.search = params.toString();\n        result = resUrl.toString();\n    }\n    return result;\n};\n/**\n * @private\n *\n * Contains fallback logic for determining a content's extent.\n *\n * The fallback priority is as follows:\n * 1) item's extent (if valid bbox)\n * 2) extent enrichment from the hub api (if coordinates are valid bbox)\n * 3) layer's extent (if spatial reference is 4326)\n *\n * If none of these conditions are met, undefined is returned.\n *\n * @param item\n * @param layer\n * @param extentEnrichment\n * @returns the correct extent in a bbox format, or undefined\n */\nconst determineExtent = (item, extentEnrichment, layer) => {\n    const itemExtent = isBBox(item.extent) ? item.extent : undefined;\n    const extentEnrichmentCoordinates = isBBox(extentEnrichment === null || extentEnrichment === void 0 ? void 0 : extentEnrichment.coordinates)\n        ? extentEnrichment.coordinates\n        : undefined;\n    const layerExtent = getProp(layer, \"extent.spatialReference.wkid\") === 4326\n        ? extentToBBox(layer.extent)\n        : undefined;\n    return itemExtent || extentEnrichmentCoordinates || layerExtent;\n};\n/**\n * @private\n *\n * Extracts the first contact from a given formal item metadata path.\n * This is particularly helpful if the contact path is either an object or an array.\n *\n * Note: the raw contact object must have the following properties:\n * - `rpIndName`: name of the individual\n * - `rpOrgName`: name of the individual's organization\n *\n * @param metadata formal item metadata\n * @param path path to the contact object/array\n * @returns\n */\nconst extractFirstContact = (metadata, path) => {\n    const rawContacts = getProp(metadata, path) || {};\n    const { rpIndName, rpOrgName } = Array.isArray(rawContacts)\n        ? rawContacts[0]\n        : rawContacts;\n    return { individualName: rpIndName, organizationName: rpOrgName };\n};\n/**\n * Determines the correct orgId for an item.\n * Note: it's undocumented, but the portal API will return orgId for items... sometimes.\n *\n * @param item\n * @param ownerUser item owner's hydrated user object\n */\nconst getItemOrgId = (item, ownerUser) => item.orgId || (ownerUser === null || ownerUser === void 0 ? void 0 : ownerUser.orgId);\n/**\n * Calculates the Publisher display info for the given item.\n * Utilizes this fallback pattern:\n * 1) Formal Item Metadata > Resource > Citation > Contact\n * 2) Formal Item Metadata > Resource > Contact\n * 3) Itemâ€™s Owner and Org Name\n * 4) Undefined (Item Owner / Org are private and we can't access additional info)\n *\n * @param item\n * @param metadata\n * @param org portal info of the item's organization\n * @param ownerUser the item owner's hydrated user\n * @returns\n */\nconst getPublisherInfo = (item, metadata, org, ownerUser) => {\n    const result = {\n        nameSource: PublisherSource.None,\n        organizationSource: PublisherSource.None,\n    };\n    const citationContact = extractFirstContact(metadata, \"metadata.dataIdInfo.idCitation.citRespParty\");\n    const resourceContact = extractFirstContact(metadata, \"metadata.dataIdInfo.idPoC\");\n    const metadataContact = extractFirstContact(metadata, \"metadata.mdContact\");\n    // Determine publisher name properties\n    const ownerFullName = getProp(ownerUser, \"fullName\");\n    if (citationContact.individualName) {\n        result.name = citationContact.individualName;\n        result.nameSource = PublisherSource.CitationContact;\n    }\n    else if (resourceContact.individualName) {\n        result.name = resourceContact.individualName;\n        result.nameSource = PublisherSource.ResourceContact;\n    }\n    else if (metadataContact.individualName) {\n        result.name = metadataContact.individualName;\n        result.nameSource = PublisherSource.MetadataContact;\n    }\n    else if (ownerFullName) {\n        result.name = ownerFullName;\n        result.username = ownerUser.username;\n        result.nameSource = PublisherSource.ItemOwner;\n    }\n    // Determine publisher org properties\n    const orgName = getProp(org, \"name\");\n    if (citationContact.organizationName) {\n        result.organization = citationContact.organizationName;\n        result.organizationSource = PublisherSource.CitationContact;\n    }\n    else if (resourceContact.organizationName) {\n        result.organization = resourceContact.organizationName;\n        result.organizationSource = PublisherSource.ResourceContact;\n    }\n    else if (metadataContact.organizationName) {\n        result.organization = metadataContact.organizationName;\n        result.organizationSource = PublisherSource.MetadataContact;\n    }\n    else if (orgName) {\n        result.organization = orgName;\n        result.orgId = getItemOrgId(item, ownerUser);\n        result.organizationSource = PublisherSource.ItemOwner;\n    }\n    // We assume the item belongs to external org if no org info is available and the item is private\n    result.isExternal =\n        result.organizationSource === PublisherSource.None &&\n            item.access !== \"public\";\n    return result;\n};\n\nexport { DatePrecision as D, getItemOrgId as a, collections as b, canUseHubApiForItem as c, determineExtent as d, getContentBoundary as e, getValueFromMetadata as f, getFamily as g, getPublisherInfo as h, includes as i, getItemSpatialReference as j, getAdditionalResources as k, isProxiedCSV as l, getHubRelativeUrl as m, getMetadataPath as n, getFamilyTypes as o, parseISODateString as p };\n","import { c as cleanUrl } from './clean-url-be7c0879.js';\n\n/* Copyright (c) 2017-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\nvar serviceRegex = new RegExp(/.+(?:map|feature|image)server/i);\n/**\n * Return the service url. If not matched, returns what was passed in\n */\nfunction parseServiceUrl(url) {\n    var match = url.match(serviceRegex);\n    if (match) {\n        return match[0];\n    }\n    else {\n        return stripQueryString(url);\n    }\n}\nfunction stripQueryString(url) {\n    var stripped = url.split('?')[0];\n    return cleanUrl(stripped);\n}\n\nexport { parseServiceUrl as p };\n"],"names":["includes","array","val","indexOf","PublisherSource","getCollectionTypes","collection","lowerCaseCollection","toLocaleLowerCase","collections","app","dataset","document","event","feedback","initiative","template","solution","map","other","site","getFamily","type","family","toLowerCase","lowerCaseType","Object","keys","find","key","some","t","getCollection","getFamilyTypes","types","concat","filter","DatePrecision","getContentBoundary","item","_a","bBox","extent","isValidItemExtent","isBBox","provenance","properties","boundary","undefined","geometry","bBoxToExtent","center","getExtentCenter","x","y","assign","extentToPolygon","spatialReference","isPortal","requestOptions","canUseHubApiForItem","access","isProxiedCSV","size","getHubRelativeUrl","identifier","typeKeywords","contentUrl","getSolutionUrl","getInitiativeTemplateUrl","path","isPageType","hubUrl","getMetadataPath","updateFrequency","reviseDate","pubDate","createDate","metadataUpdateFrequency","metadataUpdatedDate","getValueFromMetadata","metadata","getProp","parseISODateString","isoString","date","precision","test","Date","Year","parts","split","Month","Day","Number","isNaN","parse","Time","getItemSpatialReference","wkid","parseInt","getAdditionalResources","rawResources","extractRawResources","resource","name","orName","url","getAdditionalResourceUrl","isDataSource","isDataSourceOfItem","castToArray","forEach","distInfo","distTranOps","onLineSrc","push","length","objectOrArray","Array","isArray","serviceUrl","parseServiceUrl","linkage","result","token","resUrl","URL","params","URLSearchParams","search","set","toString","determineExtent","extentEnrichment","layer","itemExtent","extentEnrichmentCoordinates","coordinates","layerExtent","extentToBBox","extractFirstContact","rawContacts","individualName","rpIndName","organizationName","rpOrgName","getItemOrgId","ownerUser","orgId","getPublisherInfo","org","nameSource","None","organizationSource","citationContact","resourceContact","metadataContact","ownerFullName","CitationContact","ResourceContact","MetadataContact","username","ItemOwner","orgName","organization","isExternal","serviceRegex","RegExp","match","stripped","cleanUrl","stripQueryString"],"sourceRoot":""}