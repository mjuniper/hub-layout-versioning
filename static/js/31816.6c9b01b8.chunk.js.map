{"version":3,"file":"static/js/31816.6c9b01b8.chunk.js","mappings":"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","sources":["../.yalc/@esri/hub-components/dist/esm/arcgis-hub-image.entry.js","../.yalc/@esri/hub-components/dist/esm/context-7d8f7366.js","../.yalc/@esri/hub-components/dist/esm/interfaces-ce953c34.js"],"sourcesContent":["import { r as registerInstance, h, H as Host, g as getElement } from './index-0d95d9d4.js';\nimport { b as bind } from './context-7d8f7366.js';\nimport { C as CORNERS } from './interfaces-ce953c34.js';\n\n/* Manages a single IntersectionObserver to be used by all components\n * usage: IntersectionObserverManager.addHandler(this.element, handler);\n *        IntersectionObserverManager.removeHandler(this.element, handler); or IntersectionObserverManager.unobserve(this.element);\n */\n/**\n * Current default hardcoded options. Currently, the IOManager is only used\n * for lazy loading. If we wanted different options for different use cases,\n * we would need to create different intersection observers for each type of use case\n * (one for lazy loading, one for ..., etc)\n */\nconst intersectionObserverOptions = {\n  rootMargin: '10%',\n};\nclass IntersectionObserverManager {\n  constructor() {\n    // private so it can only be called from inside\n    this.intersectionObserver = new IntersectionObserver(this.onEnteredViewport.bind(this), intersectionObserverOptions);\n    this.handlers = new WeakMap();\n  }\n  /**\n   * Static method to create an instance of IntersectionObserverManager\n   */\n  static create() {\n    if (!IntersectionObserverManager.instance) {\n      IntersectionObserverManager.instance = new IntersectionObserverManager();\n    }\n    return IntersectionObserverManager.instance;\n  }\n  /**\n   * Static method to add a intersection handler for a particular element\n   */\n  static addHandler(element, fn) {\n    this.create();\n    this.instance.addHandler(element, fn);\n  }\n  /**\n   * Static method to remove a particular intersection handler for a particular element\n   */\n  static removeHandler(element, fn) {\n    if (this.instance) {\n      this.instance.removeHandler(element, fn);\n    }\n  }\n  /**\n   * Static method to remove all intersection handlers for a particular element\n   */\n  static unobserve(element) {\n    if (this.instance) {\n      this.instance.unobserve(element);\n    }\n  }\n  /**\n   * Instance method to add a intersection handler for a particular element\n   */\n  addHandler(element, fn) {\n    if (!this.handlers.has(element)) {\n      // if we are not already observing the element, initialize the handlers array and observe the element\n      this.handlers.set(element, []);\n      this.intersectionObserver.observe(element);\n    }\n    // push the fn into the handlers array if it is not already there\n    const handlers = this.handlers.get(element);\n    if (!handlers.includes(fn)) {\n      handlers.push(fn);\n    }\n  }\n  /**\n   * Instance method to remove a particular intersection handler for a particular element\n   */\n  removeHandler(element, fn) {\n    // conditionally destroy a handler if one exists for the given element and fn\n    if (this.handlers.has(element)) {\n      // if we are observing the element\n      const handlers = this.handlers.get(element);\n      const idx = handlers.indexOf(fn);\n      // filter out the fn\n      const newHandlers = handlers.filter((_, _idx) => _idx !== idx);\n      if (newHandlers.length) {\n        // if it is not the last handler for the element, set the filtered handlers as the new handlers array for the element\n        this.handlers.set(element, newHandlers);\n      }\n      else {\n        // if it is the last handler for the element, remove the handlers array and unobserve the element\n        this.handlers.delete(element);\n        this.intersectionObserver.unobserve(element);\n      }\n    }\n  }\n  /**\n   * Instance method to remove all intersection handlers for a particular element\n   */\n  unobserve(element) {\n    if (this.handlers.has(element)) {\n      // if we were observing the element, delete its handlers array and unobserve the element\n      this.handlers.delete(element);\n      this.intersectionObserver.unobserve(element);\n    }\n  }\n  onEnteredViewport(entries) {\n    // we wrap the callback in requestanimationframe to prevent an (benign) error related to the observer not being able to deliveer all observations within a single animation frame\n    requestAnimationFrame(_ => {\n      entries.forEach(e => {\n        var _a;\n        if (e.isIntersecting) {\n          const handlers = (_a = this.handlers.get(e.target)) !== null && _a !== void 0 ? _a : [];\n          handlers.forEach(handler => handler());\n        }\n      });\n    });\n  }\n}\n\nconst arcgisHubImageCss = \":host{display:block;width:100%}:host(.group-thumbnail)>img{display:block;aspect-ratio:200 / 133;-o-object-fit:cover;object-fit:cover}img{display:block;width:100%}.rounded-corners{border-radius:0.75rem}\";\n\nconst ArcgisHubImage = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    /**\n     * If true, the image will support lazy loading\n     * and will only load the src when in the viewport\n     */\n    this.lazy = false;\n    /**\n     * The style of the image's corners\n     */\n    this.corners = CORNERS.square;\n    /**\n     * Does the original image source have an error when loading\n     */\n    this.hasError = false;\n    /**\n     * Is the component on screen currently; used with lazy loading\n     */\n    this.inViewport = false;\n    bind(this, 'setImageEl', 'handleIntersection');\n  }\n  /**\n   * Get the image url to render with, either fallback or original src\n   */\n  get _imageUrl() {\n    let imageUrl = this.src;\n    /**\n     *  ways to make fallback image happen:\n     * 1. src doesn't exist\n     * 2. error happened\n     *\n     * Way to make empty string return:\n     * 1. lazy loading AND is not in viewport\n     */\n    // no src given\n    if (!this.src) {\n      imageUrl = this.fallback;\n    }\n    // was an error in loading src image\n    if (this.hasError) {\n      imageUrl = this.fallback;\n    }\n    // lazy loading supported and element is off screen\n    if (this.lazy && !this.inViewport) {\n      imageUrl = undefined;\n    }\n    return imageUrl;\n  }\n  componentWillLoad() {\n    if (this.lazy) {\n      this.observe();\n    }\n  }\n  disconnectedCallback() {\n    if (this.lazy) {\n      this.unobserve();\n    }\n  }\n  observe() {\n    IntersectionObserverManager.addHandler(this.element, this.handleIntersection);\n  }\n  unobserve() {\n    IntersectionObserverManager.unobserve(this.element);\n  }\n  handleIntersection() {\n    this.inViewport = true;\n    this.unobserve();\n  }\n  /**\n   * @param el - HTMLImageElement in the component\n   * Creates a ref to the image to use with error\n   */\n  setImageEl(el) {\n    this.imageEl = el;\n  }\n  /**\n   * On render, check to see if image had error\n   * If there was an error, then set state and remove listener.\n   * Else add listener for errors\n   */\n  componentDidRender() {\n    if (this.imageEl) {\n      const onError = () => {\n        this.hasError = true;\n        this.imageEl.removeEventListener('error', onError);\n      };\n      this.imageEl.addEventListener('error', onError);\n    }\n  }\n  /**\n   * Renders the image\n   * @returns Image tag\n   */\n  renderImage() {\n    return this._imageUrl &&\n      h(\"img\", { alt: this.alt, class: {\n          'rounded-corners': this.corners === CORNERS.round,\n        }, ref: this.setImageEl, src: this._imageUrl });\n  }\n  render() {\n    return h(Host, { \"data-element\": \"image\" }, this.renderImage());\n  }\n  get element() { return getElement(this); }\n};\nArcgisHubImage.style = arcgisHubImageCss;\n\nexport { ArcgisHubImage as arcgis_hub_image };\n","const bind = (context, ...methodNames) => {\n  methodNames.forEach(methodName => {\n    if (typeof context[methodName] !== 'function') {\n      throw new Error(`Cannot bind context. ${methodName} must be a function`);\n    }\n    context[methodName] = context[methodName].bind(context);\n  });\n};\n\nexport { bind as b };\n","var ALIGNMENTS;\n(function (ALIGNMENTS) {\n  ALIGNMENTS[\"start\"] = \"start\";\n  ALIGNMENTS[\"center\"] = \"center\";\n  ALIGNMENTS[\"end\"] = \"end\";\n})(ALIGNMENTS || (ALIGNMENTS = {}));\nvar CORNERS;\n(function (CORNERS) {\n  CORNERS[\"square\"] = \"square\";\n  CORNERS[\"round\"] = \"round\";\n})(CORNERS || (CORNERS = {}));\nvar DROP_SHADOWS;\n(function (DROP_SHADOWS) {\n  DROP_SHADOWS[\"none\"] = \"none\";\n  DROP_SHADOWS[\"low\"] = \"low\";\n  DROP_SHADOWS[\"medium\"] = \"medium\";\n  DROP_SHADOWS[\"heavy\"] = \"heavy\";\n})(DROP_SHADOWS || (DROP_SHADOWS = {}));\nvar LAYOUTS;\n(function (LAYOUTS) {\n  LAYOUTS[\"simple\"] = \"simple\";\n  LAYOUTS[\"dataViz\"] = \"dataViz\";\n  LAYOUTS[\"moreInfo\"] = \"moreInfo\";\n})(LAYOUTS || (LAYOUTS = {}));\nvar UNIT_POSITIONS;\n(function (UNIT_POSITIONS) {\n  UNIT_POSITIONS[\"before\"] = \"before\";\n  UNIT_POSITIONS[\"after\"] = \"after\";\n  UNIT_POSITIONS[\"below\"] = \"below\";\n})(UNIT_POSITIONS || (UNIT_POSITIONS = {}));\nvar VISUAL_INTEREST;\n(function (VISUAL_INTEREST) {\n  VISUAL_INTEREST[\"none\"] = \"none\";\n  VISUAL_INTEREST[\"sparkline\"] = \"sparkline\";\n  VISUAL_INTEREST[\"icon\"] = \"icon\";\n  VISUAL_INTEREST[\"logo\"] = \"logo\";\n})(VISUAL_INTEREST || (VISUAL_INTEREST = {}));\nvar IMAGE_TYPES;\n(function (IMAGE_TYPES) {\n  IMAGE_TYPES[\"thumbnail\"] = \"thumbnail\";\n  IMAGE_TYPES[\"icon\"] = \"icon\";\n})(IMAGE_TYPES || (IMAGE_TYPES = {}));\n\nexport { ALIGNMENTS as A, CORNERS as C, DROP_SHADOWS as D, IMAGE_TYPES as I, LAYOUTS as L, UNIT_POSITIONS as U, VISUAL_INTEREST as V };\n"],"names":["intersectionObserverOptions","rootMargin","IntersectionObserverManager","this","intersectionObserver","IntersectionObserver","onEnteredViewport","bind","handlers","WeakMap","element","fn","has","set","observe","get","includes","push","idx","indexOf","newHandlers","filter","_","_idx","length","delete","unobserve","entries","requestAnimationFrame","forEach","e","_a","isIntersecting","target","handler","instance","create","addHandler","removeHandler","ArcgisHubImage","hostRef","registerInstance","lazy","corners","CORNERS","hasError","inViewport","imageUrl","src","fallback","undefined","handleIntersection","el","imageEl","addEventListener","onError","removeEventListener","_imageUrl","h","alt","class","ref","setImageEl","Host","renderImage","getElement","style","context","methodNames","methodName","Error","ALIGNMENTS","DROP_SHADOWS","LAYOUTS","UNIT_POSITIONS","VISUAL_INTEREST","IMAGE_TYPES"],"sourceRoot":""}