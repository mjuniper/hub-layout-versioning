{"version":3,"file":"static/js/51274.49dadf43.chunk.js","mappings":"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","sources":["../.yalc/@esri/hub-components/dist/esm/fetch-eff7ab83.js","../.yalc/@esri/hub-components/dist/esm/query-15c2c6ed.js","../.yalc/@esri/hub-components/dist/esm/request-be948455.js","../.yalc/@esri/hub-components/dist/esm/slugs-150ad0db.js","../.yalc/@esri/hub-components/dist/esm/tslib.es6-e75776ba.js"],"sourcesContent":["import { _ as __rest } from './tslib.es6-e75776ba.js';\nimport { g as getEnrichmentErrors, f as fetchItemEnrichments } from './_enrichments-9747f1f3.js';\nimport { c as cloneObject, i as isNil } from './util-2150bd9e.js';\nimport { p as parseDatasetId, i as isSlug, a as addContextToSlug, g as getLayer } from './slugs-150ad0db.js';\nimport { h as hubApiRequest } from './request-be948455.js';\nimport { n as normalizeItemType, c as composeContent, g as getItemLayer, i as isLayerView, a as getProxyUrl } from './compose-cc2f466a.js';\nimport { i as includes, g as getFamily, c as canUseHubApiForItem } from './_internal-f8d6239a.js';\nimport { q as queryFeatures } from './query-15c2c6ed.js';\nimport { p as parseServiceUrl } from './helpers-a80c0291.js';\nimport { g as getItem } from './get-f2cd18e7.js';\n\nconst MAP_OR_FEATURE_SERVER_URL_REGEX = /\\/(map|feature)server/i;\n/**\n *\n * @param url\n * @returns true if the url is of a map or feature service\n */\nconst isMapOrFeatureServerUrl = (url) => {\n    return MAP_OR_FEATURE_SERVER_URL_REGEX.test(url);\n};\n\n/**\n * concat an array of arrays\n * excluding any elements of the top level array\n * that are not actually arrays\n * @param arrays An array of arrays\n * @returns concatenated array\n * @private\n */\nconst maybeConcat = (arrays) => {\n    const result = [].concat.apply([], arrays.filter(Array.isArray));\n    return result.length ? result : undefined;\n};\n\n// TODO: need to fetch data for client-side layer views as well\n// determine if we should fetch data for an item\nconst shouldFetchData = (item) => {\n    const type = normalizeItemType(item);\n    const family = getFamily(type);\n    const dataFamilies = [\"template\", \"solution\"];\n    const dataTypes = [\"Web Map\", \"Web Scene\"];\n    return includes(dataFamilies, family) || includes(dataTypes, type);\n};\n/**\n * get the default list of enrichments to fetch for content\n * @param item\n * @returns the default list of enrichments to fetch for content\n * @private\n */\nconst getContentEnrichments = (item) => {\n    // we fetch these enrichments for all content types\n    const enrichments = [\n        \"groupIds\",\n        \"metadata\",\n        \"ownerUser\",\n        \"org\",\n    ];\n    // we only fetch data for certain content\n    if (shouldFetchData(item)) {\n        enrichments.push(\"data\");\n    }\n    // we fetch server and layers for map and feature services\n    return isMapOrFeatureServerUrl(item.url)\n        ? enrichments.concat(\"server\", \"layers\")\n        : enrichments;\n};\n// build up request options to only include the above enrichments\n// that we fetch from the Hub API, and to optionally filter by slug\nconst getHubEnrichmentsOptions = (requestOptions, slug) => {\n    const opts = cloneObject(requestOptions);\n    opts.params = Object.assign(Object.assign({}, opts.params), { \n        // TODO: we should fetch errors too\n        // TODO: stop fetching recordCount at next breaking change\n        \"fields[datasets]\": \"slug,boundary,extent,recordCount,searchDescription,statistics\" });\n    if (slug) {\n        opts.params[\"filter[slug]\"] = slug;\n    }\n    return opts;\n};\n// extract the ids and enrichments from the Hub API response\nconst getDatasetEnrichments = (dataset) => {\n    const { itemId, layerId: layerIdString } = parseDatasetId(dataset.id);\n    const layerId = layerIdString && parseInt(layerIdString, 10);\n    const { slug, boundary, extent, recordCount, searchDescription, statistics } = dataset.attributes;\n    return {\n        itemId,\n        layerId,\n        slug,\n        boundary,\n        extent,\n        recordCount,\n        searchDescription,\n        statistics,\n    };\n};\n/**\n * fetch enrichment from the Hub API by slug\n * @param slug\n * @param requestOptions\n * @returns enrichments from the Hub API (slug, boundary, statistic, etc)\n * @private\n */\nconst fetchHubEnrichmentsBySlug = async (slug, requestOptions) => {\n    // NOTE: we don't catch errors here b/c\n    // searching by slug is the first step in fetchContent()\n    // and if this fails, we don't have an id to fall back on\n    const response = await hubApiRequest(`/datasets`, getHubEnrichmentsOptions(requestOptions, slug));\n    return getDatasetEnrichments(response.data[0]);\n};\n/**\n * fetch enrichment from the Hub API by id\n * @param slug\n * @param requestOptions\n * @returns enrichments from the Hub API (slug, boundary, statistic, etc)\n * @private\n */\nconst fetchHubEnrichmentsById = async (hubId, requestOptions) => {\n    try {\n        const response = await hubApiRequest(`/datasets/${hubId}`, getHubEnrichmentsOptions(requestOptions));\n        return getDatasetEnrichments(response.data);\n    }\n    catch (e) {\n        // dataset record not found, just log the error\n        // b/c we can still look up the item and enrichments by id\n        return { errors: getEnrichmentErrors(e) };\n    }\n};\n\nconst hasFeatures = (contentType) => [\"Feature Layer\", \"Table\"].includes(contentType);\nconst maybeFetchLayerEnrichments = async (itemAndEnrichments, options) => {\n    // determine if this is a client-side feature layer view\n    const { item, data } = itemAndEnrichments;\n    let { layers } = itemAndEnrichments;\n    let layer = layers && getItemLayer(item, layers, options && options.layerId);\n    // TODO: Remove once we stop supporting ArcGIS Servers below version 10.5.\n    // The /layers endpoint of some earlier servers return layers and tables\n    // without certain critical properties, such as type. If this is the case,\n    // fetch the fully hydrated target layer and stab it onto the layers array.\n    // See https://devtopia.esri.com/dc/hub/issues/3488 for more details\n    if (layer && !layer.type) {\n        const layerUrl = parseServiceUrl(item.url) + \"/\" + layer.id;\n        const getLayerOptions = Object.assign({ url: layerUrl }, options); // works whether options is defined or not\n        layer = await getLayer(getLayerOptions);\n        layers = layers.map((unhydratedLayer) => {\n            return unhydratedLayer.id === layer.id ? layer : unhydratedLayer;\n        });\n    }\n    const layerEnrichments = layer && isLayerView(layer) && !data\n        ? // NOTE: I'm not sure what conditions causes a layer view\n            // to store (at least part of) it's view definition in item data\n            // it seems that most do not, but until we have a reliable signal\n            // we just fetch the item data for all layer views\n            await fetchItemEnrichments(item, [\"data\"], options)\n        : undefined;\n    return Object.assign(Object.assign(Object.assign({}, itemAndEnrichments), layerEnrichments), { \n        // merge error arrays\n        errors: maybeConcat([itemAndEnrichments.errors, layerEnrichments === null || layerEnrichments === void 0 ? void 0 : layerEnrichments.errors]), \n        // Also remove once we stop supporting ArcGIS Servers below version 10.5\n        layers });\n};\nconst fetchItemAndEnrichments = async (itemId, options) => {\n    // fetch the item\n    const item = await getItem(itemId, options);\n    // The Hub Application expects the item url of proxied CSVs to point to the\n    // proxying feature service. Stabbing it on here maintains that consistency\n    // and also helps us fetch and calculate the correct reference layer\n    item.url = getProxyUrl(item, options) || item.url;\n    // fetch the enrichments\n    const enrichmentsToFetch = (options === null || options === void 0 ? void 0 : options.enrichments) || getContentEnrichments(item);\n    const enrichments = await fetchItemEnrichments(item, enrichmentsToFetch, options);\n    return maybeFetchLayerEnrichments(Object.assign(Object.assign({}, enrichments), { item }), options);\n};\nconst fetchContentById = async (hubId, options) => {\n    // start by fetching the item and item enrichments\n    const { itemId } = parseDatasetId(hubId);\n    const _a = await fetchItemAndEnrichments(itemId, options), { item } = _a, itemEnrichments = __rest(_a, [\"item\"]);\n    // did the caller request a specific layer\n    const specifiedLayerId = options && options.layerId;\n    // if this is a public item and we're not in enterprise\n    // fetch the slug and remaining enrichments from the Hub API\n    // const { slug, layerId, boundary, extent, searchDescription, statistics } =\n    const hubEnrichments = canUseHubApiForItem(item, options)\n        ? await fetchHubEnrichmentsById(hubId, options)\n        : {};\n    const layerId = hubEnrichments.layerId;\n    // return a new content object composed from the item and enrichments we fetched\n    return composeContent(item, Object.assign(Object.assign(Object.assign({ requestOptions: options }, itemEnrichments), hubEnrichments), { \n        // prefer specified layer id if any\n        layerId: isNil(specifiedLayerId) ? layerId : specifiedLayerId, \n        // merge error arrays\n        errors: maybeConcat([itemEnrichments.errors, hubEnrichments.errors]) }));\n};\nconst fetchContentBySlug = async (fullyQualifiedSlug, options) => {\n    // we only have a slug, not an item id, so we start by\n    // fetching the item id (and enrichments) from the Hub API\n    // NOTE: if we are in enterprise this will throw an error\n    let hubEnrichments = await fetchHubEnrichmentsBySlug(fullyQualifiedSlug, options);\n    const { itemId } = hubEnrichments;\n    let { layerId } = hubEnrichments;\n    // now we can fetch the item and item enrichments\n    const _a = await fetchItemAndEnrichments(itemId, options), { item } = _a, itemEnrichments = __rest(_a, [\"item\"]);\n    // did the caller request a specific layer\n    const specifiedLayerId = options && options.layerId;\n    if (!isNil(specifiedLayerId) && specifiedLayerId !== layerId) {\n        // we fetched Hub enrichments by slug for another record,\n        // most likely the record for the parent service of this layer,\n        // so we need to fetch them for the specified layer instead\n        layerId = specifiedLayerId;\n        hubEnrichments = Object.assign(Object.assign({}, hubEnrichments), (await fetchHubEnrichmentsById(`${itemId}_${layerId}`, options)));\n    }\n    return composeContent(item, Object.assign(Object.assign(Object.assign({ requestOptions: options }, itemEnrichments), hubEnrichments), { layerId, \n        // Note that we are not extracting the slug for the specified layer.\n        // It seems that the old client composer code always populated the slug\n        // field with the slug that was passed into the function (typically the\n        // slug of the parent service). To maintain parity, we do the same here.\n        //\n        // TODO: should we prefer the slug of the fetched layer instead?\n        // return a new content object composed from the item and enrichments we fetched\n        slug: fullyQualifiedSlug, \n        // merge error arrays\n        errors: maybeConcat([itemEnrichments.errors, hubEnrichments.errors]) }));\n};\nconst fetchContentRecordCount = async (content, requestOptions) => {\n    const { url, viewDefinition } = content;\n    const where = viewDefinition === null || viewDefinition === void 0 ? void 0 : viewDefinition.definitionExpression;\n    try {\n        const response = await queryFeatures(Object.assign(Object.assign({}, requestOptions), { url,\n            where, returnCountOnly: true }));\n        return response.count;\n    }\n    catch (_a) {\n        // swallow the error and return Infinity as a flag that the caller can act on\n        // NOTE: this is what the -ui app currently expects, see:\n        // https://github.com/ArcGIS/opendata-ui/blob/300601918eb2dee79a89314880541ecd60f21e68/packages/opendata-ui/app/utils/composer.js#L273-L279\n        // however, we should probably push the error message into content.errors instead\n        return Infinity;\n    }\n};\n/**\n * Fetch enriched content from the Portal and Hub APIs.\n * @param identifier content slug or id\n * @param options Request options with additional options to control how the content or enrichments are fetched\n * @returns A content object composed of the backing item and enrichments\n *\n * ```js\n * import { fetchContent } from '@esri/hub-common'\n * // fetch content by slug\n * const content = await fetchContent('my-org::item-name')\n * ```\n */\nconst fetchContent = async (identifier, options) => {\n    const content = isSlug(identifier)\n        ? await fetchContentBySlug(addContextToSlug(identifier, options === null || options === void 0 ? void 0 : options.siteOrgKey), options)\n        : await fetchContentById(identifier, options);\n    // fetch record count for content that has features (e.g. layers, tables, or proxied CSVs)\n    const { layer, type } = content;\n    // it's too expensive to always fetch the live record count up front\n    // in order to avoid a breaking change, we're including the cached recordCount\n    // in the list of enrichments we fetch from the Hub API and using that\n    // and only fetching the live record count in cases where we don't have that\n    // TODO: fetchContent() should NOT fetch record count in the next breaking change\n    const canQuery = !!layer && hasFeatures(type);\n    content.recordCount =\n        canQuery && (isNil(content.recordCount) || content.viewDefinition)\n            ? // no cached count, or this is client-side layer view, fetch the count\n                await fetchContentRecordCount(content, options)\n            : content.recordCount;\n    return content;\n};\n\nexport { fetchContent as f };\n","import { a as __assign } from './tslib.es6-b2e8cdb8.js';\nimport { r as request } from './request-c15cc2af.js';\nimport { c as cleanUrl } from './clean-url-be7c0879.js';\nimport { a as appendCustomParams } from './append-custom-params-fd9b7e72.js';\n\n/* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n/**\n * ```js\n * import { getFeature } from '@esri/arcgis-rest-feature-layer';\n * //\n * const url = \"https://services.arcgis.com/V6ZHFr6zdgNZuVG0/arcgis/rest/services/Landscape_Trees/FeatureServer/0\";\n * //\n * getFeature({\n *   url,\n *   id: 42\n * }).then(feature => {\n *  console.log(feature.attributes.FID); // 42\n * });\n * ```\n * Get a feature by id.\n *\n * @param requestOptions - Options for the request\n * @returns A Promise that will resolve with the feature or the [response](https://developer.mozilla.org/en-US/docs/Web/API/Response) itself if `rawResponse: true` was passed in.\n */\nfunction getFeature(requestOptions) {\n    var url = cleanUrl(requestOptions.url) + \"/\" + requestOptions.id;\n    // default to a GET request\n    var options = __assign({ httpMethod: \"GET\" }, requestOptions);\n    return request(url, options).then(function (response) {\n        if (options.rawResponse) {\n            return response;\n        }\n        return response.feature;\n    });\n}\n/**\n * ```js\n * import { queryFeatures } from '@esri/arcgis-rest-feature-layer';\n * //\n * queryFeatures({\n *   url: \"http://sampleserver6.arcgisonline.com/arcgis/rest/services/Census/MapServer/3\",\n *   where: \"STATE_NAME = 'Alaska'\"\n * })\n *   .then(result)\n * ```\n * Query a feature service. See [REST Documentation](https://developers.arcgis.com/rest/services-reference/query-feature-service-layer-.htm) for more information.\n *\n * @param requestOptions - Options for the request\n * @returns A Promise that will resolve with the query response.\n */\nfunction queryFeatures(requestOptions) {\n    var queryOptions = appendCustomParams(requestOptions, [\n        \"where\",\n        \"objectIds\",\n        \"relationParam\",\n        \"time\",\n        \"distance\",\n        \"units\",\n        \"outFields\",\n        \"geometry\",\n        \"geometryType\",\n        \"spatialRel\",\n        \"returnGeometry\",\n        \"maxAllowableOffset\",\n        \"geometryPrecision\",\n        \"inSR\",\n        \"outSR\",\n        \"gdbVersion\",\n        \"returnDistinctValues\",\n        \"returnIdsOnly\",\n        \"returnCountOnly\",\n        \"returnExtentOnly\",\n        \"orderByFields\",\n        \"groupByFieldsForStatistics\",\n        \"outStatistics\",\n        \"returnZ\",\n        \"returnM\",\n        \"multipatchOption\",\n        \"resultOffset\",\n        \"resultRecordCount\",\n        \"quantizationParameters\",\n        \"returnCentroid\",\n        \"resultType\",\n        \"historicMoment\",\n        \"returnTrueCurves\",\n        \"sqlFormat\",\n        \"returnExceededLimitFeatures\",\n        \"f\"\n    ], {\n        httpMethod: \"GET\",\n        params: __assign({ \n            // set default query parameters\n            where: \"1=1\", outFields: \"*\" }, requestOptions.params)\n    });\n    return request(cleanUrl(requestOptions.url) + \"/query\", queryOptions);\n}\n\nexport { getFeature as g, queryFeatures as q };\n","import { g as getHubApiUrl } from './api-3826163b.js';\n\n/**\n * @private\n */\nfunction buildUrl(params) {\n    const { host, path, query } = params;\n    const baseUrl = host.endsWith(\"/\") ? host : `${host}/`;\n    const url = new URL(path, baseUrl);\n    url.search = buildQueryString(query);\n    return url.toString();\n}\nfunction buildQueryString(params = {}) {\n    const queryParams = Object.keys(params)\n        .filter((key) => {\n        return params[key] !== undefined;\n    })\n        .reduce((acc, key) => {\n        acc[key] = params[key];\n        return acc;\n    }, {});\n    return new URLSearchParams(queryParams).toString();\n}\n\n/**\n * remote server error\n */\nclass RemoteServerError extends Error {\n    constructor(message, url, status) {\n        super(message);\n        this.status = status;\n        this.url = url;\n    }\n}\n/**\n * ```js\n * import { hubApiRequest } from \"@esri/hub-common\";\n * //\n * hubApiRequest(\n *   \"/datasets\",\n *   requestOptions\n * })\n *   .then(response);\n * ```\n * make a request to the Hub API\n * @param route API route\n * @param requestOptions request options\n */\nfunction hubApiRequest(route, requestOptions) {\n    // merge in default request options\n    const options = Object.assign({ \n        // why do we default to GET w/ our API?\n        httpMethod: \"GET\" }, requestOptions);\n    // use fetch override if any\n    const _fetch = options.fetch || fetch;\n    // merge in default headers\n    const headers = Object.assign({ \"Content-Type\": \"application/json\" }, options.headers);\n    // build query params/body based on requestOptions.params\n    let query;\n    let body;\n    if (options.httpMethod === \"GET\") {\n        // pass params in query string\n        query = options.params;\n    }\n    else {\n        // pass params in request body\n        body = JSON.stringify(options.params);\n    }\n    // build Hub API URL\n    const url = buildUrl({\n        host: getHubApiUrl(options),\n        path: `/api/v3/${route}`.replace(/\\/\\//g, \"/\"),\n        query,\n    });\n    return _fetch(url, {\n        method: options.httpMethod,\n        headers,\n        body,\n    }).then((resp) => {\n        if (resp.ok) {\n            return resp.json();\n        }\n        else {\n            throw new RemoteServerError(resp.statusText, url, resp.status);\n        }\n    });\n}\n\nexport { RemoteServerError as R, buildUrl as b, hubApiRequest as h };\n","import { r as request } from './request-c15cc2af.js';\nimport { c as cleanUrl } from './clean-url-be7c0879.js';\nimport { i as isGuid } from './is-guid-8127621d.js';\n\n/* Copyright (c) 2018 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n/**\n * ```js\n * import { getLayer } from '@esri/arcgis-rest-feature-layer';\n * //\n * getLayer({\n *   url: \"https://sampleserver6.arcgisonline.com/arcgis/rest/services/ServiceRequest/FeatureServer/0\"\n * })\n *   .then(response) // { name: \"311\", id: 0, ... }\n * ```\n * Layer (Feature Service) request. See the [REST Documentation](https://developers.arcgis.com/rest/services-reference/layer-feature-service-.htm) for more information.\n *\n * @param options - Options for the request.\n * @returns A Promise that will resolve with the addFeatures response.\n */\nfunction getLayer(options) {\n    return request(cleanUrl(options.url), options);\n}\n\n//////////////////////\n// Slug Helpers\n//////////////////////\n/**\n * Parse item ID and layer ID (if any) from dataset record ID\n *\n * @param datasetId Hub API dataset record id ({itemId}_{layerId} or {itemId})\n * @returns A hash with the `itemId` and `layerId` (if any)\n */\nfunction parseDatasetId(datasetId) {\n    const [itemId, layerId] = datasetId ? datasetId.split(\"_\") : [];\n    return { itemId, layerId };\n}\n/**\n * Determine if an identifier is a Hub API slug\n *\n * @param identifier Hub API slug ({orgKey}::{title-as-slug} or {title-as-slug})\n * or record id ((itemId}_{layerId} or {itemId})\n * @returns true if the identifier is valid _and_ is **not** a record id\n */\nfunction isSlug(identifier) {\n    const { itemId } = parseDatasetId(identifier);\n    if (!itemId || isGuid(itemId)) {\n        // it's either invalid, or an item id, or a dataset id\n        return false;\n    }\n    // otherwise assume it's a slug\n    return true;\n}\n/**\n * Add a context (prefix) to slug if it doesn't already have one\n *\n * @param slug Hub API slug (with or without context)\n * @param context usually a portal's orgKey\n * @returns slug with context ({context}::{slug})\n */\nfunction addContextToSlug(slug, context) {\n    // the slug has an org key already e.g. dc::crime-incidents\n    if (/.+::.+/.test(slug)) {\n        return slug;\n        // the slug belongs to the org that owns the site e.g. crime-incidents\n    }\n    else {\n        return `${context}::${slug}`;\n    }\n}\n\nexport { addContextToSlug as a, getLayer as g, isSlug as i, parseDatasetId as p };\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nexport { __rest as _ };\n"],"names":["MAP_OR_FEATURE_SERVER_URL_REGEX","maybeConcat","arrays","result","concat","apply","filter","Array","isArray","length","undefined","getContentEnrichments","item","url","enrichments","type","normalizeItemType","family","getFamily","includes","shouldFetchData","push","test","getHubEnrichmentsOptions","requestOptions","slug","opts","cloneObject","params","Object","assign","getDatasetEnrichments","dataset","parseDatasetId","id","itemId","layerIdString","layerId","parseInt","attributes","boundary","extent","recordCount","searchDescription","statistics","fetchHubEnrichmentsBySlug","hubApiRequest","response","data","fetchHubEnrichmentsById","hubId","errors","getEnrichmentErrors","maybeFetchLayerEnrichments","itemAndEnrichments","options","layers","layer","getItemLayer","layerUrl","parseServiceUrl","getLayerOptions","getLayer","map","unhydratedLayer","isLayerView","fetchItemEnrichments","layerEnrichments","fetchItemAndEnrichments","getItem","getProxyUrl","enrichmentsToFetch","fetchContentById","_a","itemEnrichments","__rest","specifiedLayerId","canUseHubApiForItem","hubEnrichments","composeContent","isNil","fetchContentBySlug","fullyQualifiedSlug","fetchContentRecordCount","content","viewDefinition","where","definitionExpression","queryFeatures","returnCountOnly","count","Infinity","fetchContent","identifier","isSlug","addContextToSlug","siteOrgKey","getFeature","cleanUrl","__assign","httpMethod","request","then","rawResponse","feature","queryOptions","appendCustomParams","outFields","buildUrl","host","path","query","baseUrl","endsWith","URL","search","queryParams","keys","key","reduce","acc","URLSearchParams","toString","buildQueryString","RemoteServerError","message","status","Error","route","body","_fetch","fetch","headers","JSON","stringify","getHubApiUrl","replace","method","resp","ok","json","statusText","datasetId","split","isGuid","context","s","e","t","p","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","propertyIsEnumerable"],"sourceRoot":""}