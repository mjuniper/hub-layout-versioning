{"version":3,"file":"static/js/84723.2caab371.chunk.js","mappings":"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","sources":["../.yalc/@esri/hub-components/dist/esm/api-3826163b.js","../.yalc/@esri/hub-components/dist/esm/arcgis-hub-catalog.entry.js"],"sourcesContent":["import { a as getPortalApiUrl } from './get-portal-api-url-2391fbac.js';\n\n/**\n * Parse the portal url, and if it matches one of the AGO\n * Url patterns, return the correct Hub Url\n * If portalUrl does not match an AGO pattern, this will\n * return `undefined`\n * @param portalUrl\n * @private\n */\nfunction _getHubUrlFromPortalHostname(portalUrl) {\n    let result;\n    if (portalUrl.match(/(qaext|\\.mapsqa)\\.arcgis.com/)) {\n        result = \"https://hubqa.arcgis.com\";\n    }\n    else if (portalUrl.match(/(devext|\\.mapsdevext)\\.arcgis.com/)) {\n        result = \"https://hubdev.arcgis.com\";\n    }\n    else if (portalUrl.match(/(www|\\.maps)\\.arcgis.com/)) {\n        result = \"https://hub.arcgis.com\";\n    }\n    return result;\n}\n\n/**\n * ```js\n * import { getHubApiUrl() } from \"@esri/hub-common\";\n * //\n * getHubApiUrl({ portal: \"https://custom.maps.arcgis.com/sharing/rest\" })\n * >> \"https://hub.arcgis.com\"\n * ```\n * Retrieves the Hub API Url associated with a specific ArcGIS Online organization.\n * @param urlOrObject a Portal URL, Portal API URL, request options object, or Portal self object\n * @returns the associated Hub API Url as a string.\n */\nfunction getHubApiUrl(urlOrObject) {\n    const hubApiUrl = urlOrObject && urlOrObject.hubApiUrl;\n    if (hubApiUrl) {\n        // this is request options w/ hubApiUrl already defined\n        return hubApiUrl;\n    }\n    return _getHubUrlFromPortalHostname(getPortalApiUrl(urlOrObject));\n}\n\nexport { getHubApiUrl as g };\n","import { r as registerInstance, h, H as Host, g as getElement } from './index-0d95d9d4.js';\nimport { i as intlManager } from './intl-manager-821aea3b.js';\nimport { A as ArcGISContextManager } from './ArcGISContextManager-546abc28.js';\nimport { H as HubError } from './getPropertyMap-7bed72e1.js';\nimport { c as cloneObject, g as findBy } from './util-2150bd9e.js';\nimport { h as hubSearch } from './HubGroups-a67cd255.js';\nimport { s as stripProtocol, l as lookupDomain } from './HubSites-36599d40.js';\nimport { i as isGuid } from './is-guid-8127621d.js';\nimport { g as getProp } from './get-prop-d82e4fa6.js';\nimport { c as getItemData } from './get-f2cd18e7.js';\nimport { m as mapBy } from './SiteBusinessRules-05d0a02f.js';\nimport './index-4e91769f.js';\nimport './get-with-default-6db049d8.js';\nimport './getPortalBaseFromOrgUrl-6a5781aa.js';\nimport './tslib.es6-3669ad41.js';\nimport './get-portal-url-423a76f5.js';\nimport './clean-url-be7c0879.js';\nimport './request-c15cc2af.js';\nimport './logger-0c7a68de.js';\nimport './get-portal-06f7947b.js';\nimport './search-3af9e278.js';\nimport './generic-search-069e22da.js';\nimport './append-custom-params-fd9b7e72.js';\nimport './extent-0f42acfc.js';\nimport './create-7cf3c372.js';\nimport './OperationError-85fd80c7.js';\nimport './get-portal-api-url-2391fbac.js';\nimport './update-fec93fc5.js';\nimport './fail-safe-1c23dad8.js';\nimport './set-prop-c51a6d0c.js';\nimport './ProjectBusinessRules-bb655b17.js';\nimport './get-item-thumbnail-url-7608a737.js';\nimport './utils-f1c97eba.js';\nimport './UserSession-d3a97494.js';\nimport './_internal-f8d6239a.js';\nimport './helpers-a80c0291.js';\nimport './_enrichments-9747f1f3.js';\nimport './getService-49b539e3.js';\nimport './tslib.es6-b2e8cdb8.js';\nimport './search-users-5cfad933.js';\nimport './request-be948455.js';\nimport './api-3826163b.js';\nimport './get-859a2960.js';\n\nconst CATALOG_SCHEMA_VERSION = 1.0;\n/**\n * Apply schema upgrades to Catalog objects\n * @param catalog\n * @returns\n */\nfunction upgradeCatalogSchema(catalog) {\n    let clone = cloneObject(catalog);\n    if (getProp(clone, \"schemaVersion\") === CATALOG_SCHEMA_VERSION) {\n        return clone;\n    }\n    else {\n        // apply migrations in order\n        clone = applyCatalogSchema(clone);\n        return clone;\n    }\n}\n/**\n * Apply the Catalog schema to the original, unversioned\n * site catalog objects\n * @param original\n * @returns\n */\nfunction applyCatalogSchema(original) {\n    if (getProp(original, \"schemaVersion\") > 1.0) {\n        return original;\n    }\n    else {\n        const catalog = {\n            schemaVersion: 1,\n            title: \"Default Catalog\",\n            scopes: {\n                item: {\n                    targetEntity: \"item\",\n                    filters: [],\n                },\n            },\n            collections: [],\n        };\n        const rawGroups = getProp(original, \"groups\");\n        let groups = [];\n        if (Array.isArray(rawGroups) && rawGroups.length) {\n            groups = rawGroups;\n        }\n        else if (typeof rawGroups === \"string\") {\n            groups = [rawGroups];\n        }\n        if (groups.length) {\n            catalog.scopes.item.filters.push({\n                predicates: [{ group: groups }],\n            });\n        }\n        return catalog;\n    }\n}\n\n/**\n * Fetch a IHubCatalog from a backing item.\n * This will apply schema upgrades to the structure\n * @param identifier\n * @param requestOptions\n * @returns\n */\nasync function fetchCatalog(identifier, requestOptions) {\n    let getPrms;\n    // identifier can be a guid or a url\n    if (identifier.indexOf(\"http\") === 0) {\n        let url = identifier;\n        // get down the the hostname\n        url = stripProtocol(url);\n        // if url does not include a hash (i.e. it's not portal)\n        // then we want to split on the first slash to get the hostname\n        // lookupDomain will handle the enterprise base urls\n        if (!url.includes(\"#\")) {\n            url = url.split(\"/\")[0];\n        }\n        getPrms = lookupDomain(url, requestOptions)\n            // get the item's data, and read the catalog out of it\n            .then(({ siteId }) => getItemData(siteId, requestOptions))\n            .then((data) => {\n            return upgradeCatalogSchema(data.catalog || {});\n        });\n    }\n    else if (isGuid(identifier)) {\n        // get the item's data, and read the catalog out of it\n        getPrms = getItemData(identifier, requestOptions).then((data) => {\n            return upgradeCatalogSchema(data.catalog || {});\n        });\n    }\n    else {\n        throw new HubError(\"Catalog.create\", \"Identifier must be a url, guid\");\n    }\n    const fetched = await getPrms;\n    return fetched;\n}\n\n/**\n * Collection Class\n *\n * Abstracts searching a Collection\n *\n * For more information, check out the [Catalog & Collection Guide](/hub.js/guides/concepts/catalog-collection/)\n */\nclass Collection {\n    constructor(collection, context) {\n        this._collection = collection;\n        this._context = context;\n    }\n    /**\n     * Create an instance of a Collection from a JSON object\n     * @param collection\n     * @param context\n     * @returns\n     */\n    static fromJson(collection, context) {\n        return new Collection(collection, context);\n    }\n    /**\n     * Return the JSON object backing the instance\n     * @returns\n     */\n    toJson() {\n        return cloneObject(this._collection);\n    }\n    // Getters\n    get label() {\n        return this._collection.label;\n    }\n    get key() {\n        return this._collection.key;\n    }\n    get include() {\n        return this._collection.include || [];\n    }\n    get scope() {\n        return this._collection.scope;\n    }\n    get sortField() {\n        return this._collection.sortField || \"title\";\n    }\n    get sortDirection() {\n        return this._collection.sortDirection || \"asc\";\n    }\n    get targetEntity() {\n        return this._collection.targetEntity;\n    }\n    /**\n     * Search the collection using a string or IQuery\n     * @param query\n     * @param options\n     * @returns\n     */\n    async search(query, options = {}) {\n        let qry;\n        if (typeof query === \"string\") {\n            // construct a query from that...\n            qry = {\n                targetEntity: this._collection.targetEntity,\n                filters: [\n                    {\n                        predicates: [\n                            {\n                                term: query,\n                            },\n                        ],\n                    },\n                ],\n            };\n        }\n        else {\n            qry = query;\n        }\n        // TODO: What should happen when a Query is passed in that has a targetEntity that doesn't match the collection's targetEntity?\n        // merge the passed in query w/ the scope\n        qry.filters = [...qry.filters, ...this.scope.filters];\n        const opts = cloneObject(options);\n        opts.requestOptions = this._context.hubRequestOptions;\n        // inject default sort info if not specified\n        opts.sortField = options.sortField || this.sortField;\n        opts.sortOrder = options.sortOrder || this.sortDirection;\n        // inject default includes if not specified\n        opts.include = options.include || this.include;\n        // execute the search and return results\n        return hubSearch(qry, opts);\n    }\n}\n\n/**\n * Catalog Class\n *\n * Abstracts working with Catalogs and fetching collections with\n * the correct scope applied.\n *\n * For more information, check out the [Catalog & Collection Guide](/hub.js/guides/concepts/catalog-collection/)\n */\nclass Catalog {\n    // internal - use static factory methods\n    constructor(catalog, context) {\n        this._containsCache = {};\n        this._catalog = catalog;\n        this._context = context;\n    }\n    /**\n     * Create a Catalog instance from a site url or itemId\n     * '''js\n     * const catalog = await Catalog.create('https://site-org.hub.arcgis.com', context);\n     * '''\n     *\n     * @param identifier\n     * @param context\n     * @returns\n     */\n    static async init(identifier, context) {\n        // if context is not passed, create a default that point to AGO prod\n        if (!context) {\n            const mgr = await ArcGISContextManager.create();\n            context = mgr.context;\n        }\n        // fetch the catalog\n        const fetched = await fetchCatalog(identifier, context.hubRequestOptions);\n        // return an instance\n        return new Catalog(fetched, context);\n    }\n    /**\n     * Create a Catalog instance from a Catalog Definition Json object\n     * @param json\n     * @param context\n     * @returns\n     */\n    static fromJson(json, context) {\n        // ensure it's in the latest structure\n        const catalog = upgradeCatalogSchema(json);\n        return new Catalog(catalog, context);\n    }\n    /**\n     * Return the JSON object backing the instance\n     * @returns\n     */\n    toJson() {\n        return cloneObject(this._catalog);\n    }\n    /**\n     * Return the schema version\n     */\n    get schemaVersion() {\n        return this._catalog.schemaVersion;\n    }\n    /**\n     * Title getter\n     */\n    get title() {\n        return this._catalog.title;\n    }\n    /**\n     * Title setter\n     */\n    set title(v) {\n        this._catalog.title = v;\n    }\n    /**\n     * Return the existing scopes hash\n     */\n    get scopes() {\n        return this._catalog.scopes;\n    }\n    /**\n     * Return an array of the entity types available in this Catalog\n     */\n    get availableScopes() {\n        return Object.keys(this.scopes);\n    }\n    /**\n     * Get the scope's query for a particular entity type\n     * @param type\n     * @returns\n     */\n    getScope(type) {\n        return this._catalog.scopes[type];\n    }\n    /**\n     * Set the scope for a specific entity type\n     * @param type\n     * @param query\n     */\n    setScope(type, query) {\n        // TODO: This needs to be much smarter in terms of merging\n        // existing filters with the new ones. Basically this\n        // hides very little complexity from the developer\n        this._catalog.scopes[type] = query;\n    }\n    /**\n     * Get the collections array. Returns simple objects not Collection instances\n     */\n    get collections() {\n        return this._catalog.collections || [];\n    }\n    /**\n     * Get the names of the collections\n     */\n    get collectionNames() {\n        return mapBy(\"key\", this.collections);\n    }\n    /**\n     * Get a Collection instance by name\n     * @param name\n     * @returns\n     */\n    getCollection(name) {\n        const json = this.collections.find((entry) => entry.key === name);\n        if (json) {\n            // clone it then merge in the associated scope filter\n            const clone = cloneObject(json);\n            const catalogScope = this.getScope(clone.scope.targetEntity);\n            if (catalogScope === null || catalogScope === void 0 ? void 0 : catalogScope.filters) {\n                clone.scope.filters = [...clone.scope.filters, ...catalogScope.filters];\n            }\n            return Collection.fromJson(clone, this._context);\n        }\n        else {\n            throw new HubError(\"getCollection\", `Collection \"${name}\" is not present in the Catalog`);\n        }\n    }\n    /**\n     * Search for Items\n     * Will throw if the Catalog does not have a scope defined for items\n     * @param query\n     * @param options\n     * @returns\n     */\n    async searchItems(query, options) {\n        if (!options) {\n            options = this.getDefaultSearchOptions(\"item\");\n        }\n        if (!this.getScope(\"item\")) {\n            const result = this.getEmptyResult();\n            result.messages = [\n                {\n                    code: \"missingScope\",\n                    message: \"Catalog does not have a scope for items\",\n                    data: {\n                        scope: \"item\",\n                    },\n                },\n            ];\n            return Promise.resolve(result);\n        }\n        else {\n            // ensure it's an item search\n            options.targetEntity = \"item\";\n            return this.search(query, options);\n        }\n    }\n    /**\n     * Does the Catalog contain a specific piece of content?\n     * @param identifier id or slug of the content\n     * @param options entityType if known; otherwise will execute one search for each scope\n     * @returns\n     */\n    async contains(identifier, options) {\n        const start = Date.now();\n        const catalog = this._catalog;\n        // check if we have cached results for this identifier\n        if (this._containsCache[identifier]) {\n            const cachedResult = cloneObject(this._containsCache[identifier]);\n            cachedResult.duration = Date.now() - start;\n            return Promise.resolve(cachedResult);\n        }\n        else {\n            // construct the response\n            const response = {\n                identifier,\n                isContained: false,\n            };\n            // construct the predicate\n            const pred = {};\n            if (isGuid(identifier)) {\n                pred.id = identifier;\n            }\n            else {\n                // treat as slug\n                pred.typekeywords = `slug|${identifier}`;\n            }\n            // construct the queries\n            const queries = [];\n            if (options.entityType) {\n                if (this.scopes[options.entityType]) {\n                    queries.push({\n                        targetEntity: options.entityType,\n                        filters: [{ predicates: [pred] }],\n                    });\n                }\n                else {\n                    // no scope for this entity type, thus it cannot be in the catalog\n                    response.duration = Date.now() - start;\n                    this._containsCache[identifier] = response;\n                    return Promise.resolve(response);\n                }\n            }\n            else {\n                // Construct a query for each scope\n                Object.keys(catalog.scopes).forEach((type) => {\n                    queries.push({\n                        targetEntity: type,\n                        filters: [{ predicates: [pred] }],\n                    });\n                });\n            }\n            // execute the queries\n            const results = await Promise.all(queries.map((q) => \n            // We set num to be 10 to account for api not doing exact matching on slugs\n            this.search(q, { targetEntity: q.targetEntity, num: 10 })));\n            // if any of the queries returned a result, then the entity is contained\n            response.isContained = results.reduce((isContained, queryResponse) => {\n                if (queryResponse.results.length) {\n                    if (pred.id) {\n                        isContained = true;\n                    }\n                    else {\n                        // slug based search, which is not exact,\n                        // so we manually verify the exact slug matches\n                        isContained = queryResponse.results.reduce((slugKeywordPresent, entry) => {\n                            if (entry.typeKeywords.includes(pred.typekeywords)) {\n                                slugKeywordPresent = true;\n                            }\n                            return slugKeywordPresent;\n                        }, false);\n                    }\n                }\n                return isContained;\n            }, false);\n            response.duration = Date.now() - start;\n            // add to cache...\n            this._containsCache[identifier] = response;\n            // return the response\n            return response;\n        }\n    }\n    /**\n     * Search for Groups\n     * Will throw if the Catalog does not have a scope defined for groups\n     * @param query\n     * @param options\n     * @returns\n     */\n    async searchGroups(query, options) {\n        if (!options) {\n            options = this.getDefaultSearchOptions(\"group\");\n        }\n        if (!this.getScope(\"group\")) {\n            const result = this.getEmptyResult();\n            result.messages = [\n                {\n                    code: \"missingScope\",\n                    message: \"Catalog does not have a scope for groups\",\n                    data: {\n                        scope: \"group\",\n                    },\n                },\n            ];\n            return Promise.resolve(result);\n        }\n        else {\n            // ensure it's an group search\n            options.targetEntity = \"group\";\n            return this.search(query, options);\n        }\n    }\n    /**\n     * Search for Users\n     * Will throw if the Catalog does not have a scope defined for users\n     * @param query\n     * @param options\n     * @returns\n     */\n    async searchUsers(query, options = {}) {\n        if (!this.getScope(\"user\")) {\n            const result = this.getEmptyResult();\n            result.messages = [\n                {\n                    code: \"missingScope\",\n                    message: \"Catalog does not have a scope for user\",\n                    data: {\n                        scope: \"user\",\n                    },\n                },\n            ];\n            return Promise.resolve(result);\n        }\n        else {\n            // ensure it's an group search\n            options.targetEntity = \"user\";\n            return this.search(query, options);\n        }\n    }\n    /**\n     * Execute a search against all the collections in the Catalog\n     * @param query\n     * @param options\n     * @returns\n     */\n    async searchCollections(query, options = {}) {\n        // build a query\n        const qry = {\n            targetEntity: \"item\",\n            filters: [\n                {\n                    predicates: [\n                        {\n                            term: query,\n                        },\n                    ],\n                },\n            ],\n        };\n        // iterate the colllections, issue searchs for each one\n        const promiseKeys = [];\n        const promises = this.collectionNames.map((name) => {\n            const col = this.getCollection(name);\n            promiseKeys.push(name);\n            qry.targetEntity = col.targetEntity;\n            return col.search(qry, options);\n        });\n        const responses = await Promise.all(promises);\n        // merge the responses into the hash\n        const hash = {};\n        for (let i = 0; i < promiseKeys.length; i++) {\n            hash[promiseKeys[i]] = responses[i];\n        }\n        return hash;\n    }\n    /**\n     * Execute a search against all the scopes in the Catalog\n     * @param query\n     * @param options\n     * @returns\n     */\n    async searchScopes(query, options = {}) {\n        const qry = {\n            targetEntity: \"item\",\n            filters: [\n                {\n                    predicates: [\n                        {\n                            term: query,\n                        },\n                    ],\n                },\n            ],\n        };\n        // iterate the scopes, issue searchs for each one\n        const promiseKeys = [];\n        const promises = this.availableScopes.map((name) => {\n            promiseKeys.push(name);\n            // make clones\n            const qryClone = cloneObject(qry);\n            const optsClone = cloneObject(options);\n            // set the target entity\n            qryClone.targetEntity = name;\n            optsClone.targetEntity = name;\n            // return the search promise\n            return this.search(qryClone, optsClone);\n        });\n        // wait for all the searches to complete\n        const responses = await Promise.all(promises);\n        // merge the responses into the hash\n        const hash = {};\n        for (let i = 0; i < promiseKeys.length; i++) {\n            hash[promiseKeys[i]] = responses[i];\n        }\n        return hash;\n    }\n    /**\n     * Execute a search against the Catalog as a whole\n     * @param query\n     * @param targetEntity\n     * @returns\n     */\n    async search(query, options) {\n        const targetEntity = options.targetEntity;\n        let qry;\n        if (typeof query === \"string\") {\n            qry = {\n                targetEntity,\n                filters: [\n                    {\n                        predicates: [\n                            {\n                                term: query,\n                            },\n                        ],\n                    },\n                ],\n            };\n        }\n        else {\n            qry = cloneObject(query);\n        }\n        // Now merge in catalog scope level filters\n        qry.filters = [...qry.filters, ...this.getScope(targetEntity).filters];\n        const opts = cloneObject(options);\n        // An Catalog instance always uses the context so we remove/replace any passed in auth\n        delete opts.authentication;\n        opts.requestOptions = this._context.hubRequestOptions;\n        return hubSearch(qry, opts);\n    }\n    /**\n     * Construct an empty result. Returned when a search is performed against an entity type that\n     * does not have a scope defined.\n     * @returns\n     */\n    getEmptyResult() {\n        return {\n            results: [],\n            total: 0,\n            hasNext: false,\n            next: null,\n        };\n    }\n    getDefaultSearchOptions(type) {\n        return {\n            targetEntity: type,\n            num: 10,\n            start: 1,\n            requestOptions: this._context.hubRequestOptions,\n        };\n    }\n}\n\nconst arcgisHubCatalogCss = \":host{display:block}calcite-radio-group{margin-bottom:1rem}\";\n\nconst ArcgisHubCatalog = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    /**\n     * Layout of each card in hub gallery\n     */\n    this.layout = \"list\";\n    this.accordionOpen = true;\n    /**\n     * List Catalogs instances created from the passed in Catalog Definition Json objects or IDs\n     */\n    this._catalogs = [];\n  }\n  async componentWillLoad() {\n    this.intl = await intlManager.loadIntlForComponent(this.element);\n    // Because there is no error message when a required prop is used outside of stencil,\n    // we need to manually add it here\n    if (!this.catalogs) {\n      console.error('<arcgis-hub-catalog> component requires one or more catalogs be provided');\n    }\n    else {\n      /**\n       * Construct a list of Catalog instances based on the type of catalogs passed in\n       * Only keep the ones with collections\n       * Emit a warning if a catalog does not have any collections\n       */\n      // The `as any[]` is needed to avoid a typescript compiler error\n      // see https://github.com/microsoft/TypeScript/issues/36390#issuecomment-641718624\n      const prms = this.catalogs.reduce((acc, c) => {\n        var _a;\n        if (typeof c === 'string') {\n          acc.push(Catalog.init(c, this.context));\n        }\n        else {\n          if ((_a = c.collections) === null || _a === void 0 ? void 0 : _a.length) {\n            acc.push(Catalog.fromJson(c, this.context));\n          }\n          else {\n            console.error(`Catalog ${c.title} will not be displayed because it does not have any collections.`);\n          }\n        }\n        return acc;\n      }, []);\n      this._catalogs = await Promise.all(prms);\n      this.activeCatalog = this._catalogs[0];\n      // Get the merged collection from the active catalog and the first collection in the active catalog\n      this.activeCollection = this.activeCatalog.getCollection(this.activeCatalog.collections[0].key);\n    }\n  }\n  /**\n   * Handle catalog radio button change\n   * Assign merged collection to activeCollection\n   * If there is no collection passed in, assign null and let Hub Gallery construct it there\n   */\n  handleCalciteRadioButtonGroupChange(evt) {\n    // Adding this additional check here to prevent errors if there are other radio button facets\n    // rendered in the gallery component\n    const selectedCatalog = findBy(this._catalogs, \"title\", evt.detail);\n    if (selectedCatalog) {\n      this.activeCatalog = selectedCatalog;\n      this.activeCollection = this.activeCatalog.getCollection(this.activeCatalog.collections[0].key);\n    }\n  }\n  /**\n   * Handle collection change\n   */\n  handleCalciteTabChange(evt) {\n    this.activeCollection = this.activeCatalog.getCollection(evt.detail.tab);\n  }\n  /**\n   * The catalog facet we want to render on top of all the other facets in hub gallery\n   */\n  renderCatalogFacet() {\n    return h(\"calcite-accordion-item\", { expanded: this.accordionOpen, heading: this.intl.t('source') }, h(\"calcite-radio-button-group\", { layout: 'vertical', name: 'catalog-group' }, this._catalogs.map((catalog, idx) => {\n      return h(\"calcite-label\", { key: catalog.title, layout: \"inline\" }, h(\"calcite-radio-button\", { checked: idx === 0, id: catalog.title, name: catalog.title, value: catalog.title }), h(\"span\", { class: \"catalog\" }, catalog.title));\n    })));\n  }\n  ;\n  renderCollections(collections) {\n    return h(\"calcite-tab-nav\", { slot: \"tab-nav\" }, collections.map((collection) => {\n      // TODO: 'active' is deprecated, replace with 'selected' once calcite version is updated\n      return h(\"calcite-tab-title\", { key: collection.key, tab: collection.key }, collection.label);\n    }));\n  }\n  render() {\n    var _a;\n    const showCollections = ((_a = this.activeCatalog) === null || _a === void 0 ? void 0 : _a.collections.length) > 1;\n    const showCatalogFacet = this._catalogs.length > 1;\n    return (h(Host, { \"data-element\": \"catalog\" }, h(\"arcgis-hub-gallery\", { additionalFacet: showCatalogFacet && this.renderCatalogFacet(), collection: this.activeCollection.toJson(), context: this.context, facets: this.facets, gallerySelection: this.gallerySelection, layout: this.layout, selectable: this.selectable, showBackToTopBtn: true, showChips: true, showFacets: true, showMoreResultsBtn: true, showResultsCount: true, showSearch: true, showSelection: this.showSelection, showSort: true, showThumbnail: this.showThumbnail }, h(\"calcite-tabs\", { layout: \"center\", scale: \"l\", slot: \"collection-select\" }, showCollections && this.renderCollections(this.activeCatalog.collections)))));\n  }\n  static get assetsDirs() { return [\"locales\"]; }\n  get element() { return getElement(this); }\n};\nArcgisHubCatalog.style = arcgisHubCatalogCss;\n\nexport { ArcgisHubCatalog as arcgis_hub_catalog };\n"],"names":["getHubApiUrl","urlOrObject","hubApiUrl","portalUrl","result","match","_getHubUrlFromPortalHostname","getPortalApiUrl","upgradeCatalogSchema","catalog","clone","cloneObject","getProp","original","schemaVersion","title","scopes","item","targetEntity","filters","collections","rawGroups","groups","Array","isArray","length","push","predicates","group","applyCatalogSchema","fetchCatalog","identifier","requestOptions","indexOf","url","stripProtocol","includes","split","getPrms","lookupDomain","then","siteId","getItemData","data","isGuid","HubError","fetched","Collection","collection","context","this","_collection","_context","label","key","include","scope","sortField","sortDirection","query","options","qry","term","opts","hubRequestOptions","sortOrder","hubSearch","Catalog","_containsCache","_catalog","v","Object","keys","type","mapBy","name","json","find","entry","catalogScope","getScope","fromJson","getDefaultSearchOptions","getEmptyResult","messages","code","message","Promise","resolve","search","start","Date","now","cachedResult","duration","response","isContained","pred","id","typekeywords","queries","entityType","forEach","all","map","q","num","results","reduce","queryResponse","slugKeywordPresent","typeKeywords","promiseKeys","promises","collectionNames","col","getCollection","responses","hash","i","availableScopes","qryClone","optsClone","authentication","total","hasNext","next","ArcGISContextManager","mgr","ArcgisHubCatalog","hostRef","registerInstance","layout","accordionOpen","_catalogs","intlManager","element","intl","catalogs","console","error","prms","acc","c","_a","init","activeCatalog","activeCollection","evt","selectedCatalog","findBy","detail","tab","h","expanded","heading","t","idx","checked","value","class","slot","showCollections","showCatalogFacet","Host","additionalFacet","renderCatalogFacet","toJson","facets","gallerySelection","selectable","showBackToTopBtn","showChips","showFacets","showMoreResultsBtn","showResultsCount","showSearch","showSelection","showSort","showThumbnail","scale","renderCollections","getElement","style"],"sourceRoot":""}