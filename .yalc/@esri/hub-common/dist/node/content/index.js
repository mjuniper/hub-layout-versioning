"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getContentTypeLabel = exports.setContentType = exports.datasetToItem = exports.datasetToContent = exports.itemToContent = exports.getContentIdentifier = exports.getTypeCategories = exports.getTypes = exports.getCategory = void 0;
const tslib_1 = require("tslib");
const collections_1 = require("../collections");
const categories_1 = require("../categories");
const utils_1 = require("../utils");
const objects_1 = require("../objects");
const urls_1 = require("../urls");
const _internal_1 = require("./_internal");
const util_1 = require("../util");
const compose_1 = require("./compose");
const get_family_1 = require("./get-family");
const slugs_1 = require("./slugs");
// re-export functions used in this file
tslib_1.__exportStar(require("./compose"), exports);
tslib_1.__exportStar(require("./get-family"), exports);
tslib_1.__exportStar(require("./slugs"), exports);
tslib_1.__exportStar(require("./fetch"), exports);
tslib_1.__exportStar(require("./types"), exports);
tslib_1.__exportStar(require("./HubContent"), exports);
// TODO: remove this at next breaking version
/**
 * ```js
 * import { getCategory } from "@esri/hub-common";
 * //
 * getCategory('Feature Layer')
 * > 'dataset'
 * ```
 * **DEPRECATED: Use getFamily() instead**
 * returns the Hub category for a given item type
 * @param itemType The ArcGIS [item type](https://developers.arcgis.com/rest/users-groups-and-items/items-and-item-types.htm).
 * @returns the category of a given item type.
 */
/* istanbul ignore next deprecated */
function getCategory(itemType = "") {
    /* tslint:disable no-console */
    console.warn("DEPRECATED: Use getFamily() instead. getCategory will be removed at the next breaking version");
    /* tslint:enable no-console */
    const collection = collections_1.getCollection(itemType);
    // for backwards compatibility
    return collection === "feedback" ? "app" : collection;
}
exports.getCategory = getCategory;
/**
 * ```js
 * import { getTypes } from "@esri/hub-common";
 * //
 * getTypes('site')
 * > [ 'hub site application' ]
 * ```
 * To do.
 * @param category The ArcGIS Hub category.
 * @returns all the item types for the given category.
 *
 */
function getTypes(category = "") {
    return categories_1.categories[category.toLowerCase()];
}
exports.getTypes = getTypes;
/**
 * ```js
 * import { getTypeCategories } from "@esri/hub-common";
 * //
 * getTypeCategories(item)
 * > [ 'Hub Site Application' ]
 * ```
 * **DEPRECATED: getTypeCategories will be removed at the next breaking version**
 * @param item Item object.
 * @returns typeCategory of the input item.
 *
 */
/* istanbul ignore next deprecated */
function getTypeCategories(item = {}) {
    /* tslint:disable no-console */
    console.warn("DEPRECATED: getTypeCategories will be removed at the next breaking version");
    /* tslint:enable no-console */
    const type = compose_1.normalizeItemType(item);
    const category = getCategory(type);
    if (category) {
        // upper case first letter and return as element in array for backwards compatibility
        const chars = Array.from(category);
        chars[0] = chars[0].toUpperCase();
        return [chars.join("")];
    }
    else {
        return ["Other"];
    }
}
exports.getTypeCategories = getTypeCategories;
/**
 * ```js
 * import { getContentIdentifier } from "@esri/hub-common";
 * //
 * getContentIdentifier(content, site)
 * > 'f12hhjk32' // id
 * // OR
 * > 'content-slug' // human-readable slug
 * ```
 * Returns the preferred identifier for a piece of content (determined by content type):
 * - Content from the 'template' and 'feedback' families return the standard id field
 * - Pages that are linked to the site parameter will return the slug defined by the site. Otherwise, the page id will be returned
 * - All other content will return the highest available item in the following hierarchy:
 *   1. slug - includes org prefix if the site parameter is a portal or has an orgKey different from the slug prefix
 *   2. hubId
 *   3. id
 * @param content The IHubContent item
 * @param site The site to compare content against
 * @returns the preferred id for the given content.
 */
function getContentIdentifier(content, site) {
    // We don't currently support slugs for hub initiative templates, solutions or surveys
    if (utils_1.includes(["template", "feedback"], content.family)) {
        return content.id;
    }
    // If it is a hub page linked to a site, return the page slug at the
    // site data instead. Because this one is the original one that was used
    // to create the page url (not mutable once created) and the slug (below)
    // generated by the hub-indexer could simply change with page name.
    if (_internal_1.isPageType(content.type, content.typeKeywords)) {
        // check if the page is linked to the current site
        const pages = objects_1.getProp(site, "data.values.pages") || [];
        // if so, return the page slug otherwise the page id
        const page = pages.find((p) => p.id === content.id);
        return page ? page.slug : content.id;
    }
    // If a slug is present, always return it
    if (content.slug) {
        let slug;
        const orgKey = objects_1.getProp(site, "domainInfo.orgKey");
        // Use namespaced slug when on the umbrella site
        if (objects_1.getProp(site, "data.values.isUmbrella")) {
            slug = content.slug;
        }
        else {
            // Use shortened slug if the slug's namespace is the same as the orgKey
            slug = slugs_1.removeContextFromSlug(content.slug, orgKey);
        }
        return slug;
    }
    return content.hubId || content.id;
}
exports.getContentIdentifier = getContentIdentifier;
/**
 * Convert a Portal item to Hub content
 *
 * @param item Portal Item
 * @returns Hub content
 * @export
 */
function itemToContent(item) {
    return compose_1.composeContent(item);
}
exports.itemToContent = itemToContent;
/**
 * Convert a Hub API dataset resource to Hub Content
 *
 * @param {DatasetResource} Dataset resource
 * @returns {IHubContent} Hub content object
 * @export
 */
function datasetToContent(dataset) {
    // extract item from dataset, create content from the item
    const item = datasetToItem(dataset);
    // extract enrichments from attributes
    const { 
    // item enrichments
    errors, boundary, metadata, slug, groupIds, orgId, orgName, organization, orgExtent, 
    // map and feature server enrichments
    server, layers, layer, recordCount, statistics, 
    // additional attributes needed
    extent, searchDescription, } = dataset.attributes;
    // get the layerId from the layer
    const layerId = layer && layer.id;
    // re-assemble the org as an enrichment
    const org = orgId && {
        id: orgId,
        name: orgName || organization,
        extent: orgExtent,
    };
    // compose a content out of the above
    return compose_1.composeContent(item, {
        layerId,
        slug,
        errors,
        // setting this to null signals to enrichMetadata to skip this
        metadata: metadata || null,
        groupIds,
        org,
        server,
        layers,
        recordCount,
        boundary,
        extent,
        searchDescription,
        statistics,
    });
}
exports.datasetToContent = datasetToContent;
/**
 * Convert a Hub API dataset resource to a portal item
 *
 * @param {DatasetResource} Dataset resource
 * @returns {IItem} portal item
 * @export
 */
function datasetToItem(dataset) {
    if (!dataset) {
        return;
    }
    const { id, attributes } = dataset;
    if (!attributes) {
        return;
    }
    // parse item id
    const { itemId } = slugs_1.parseDatasetId(id);
    // read item properties from attributes
    // NOTE: we attempt to read all item properties
    // even though some may not be currently returned
    const { 
    // start w/ item properties from
    // https://developers.arcgis.com/rest/users-groups-and-items/item.htm
    owner, orgId, created, 
    // the Hub API returns item.modified in attributes.itemModified (below)
    modified, 
    // NOTE: we use attributes.name to store the title or the service/layer name
    // but in Portal name is only used for file types to store the file name (read only)
    name, title, type, typeKeywords, description, snippet, tags, thumbnail, 
    // the Hub API returns item.extent in attributes.itemExtent (below)
    // extent,
    categories, contentStatus, 
    // the Hub API doesn't currently return spatialReference
    spatialReference, 
    // the Hub API doesn't currently return accessInformation
    accessInformation, licenseInfo, culture, url, access, 
    // the Hub API doesn't currently return proxyFilter
    proxyFilter, properties, 
    // the Hub API doesn't currently return appCategories, industries,
    // languages, largeThumbnail, banner, screenshots, listed, ownerFolder
    appCategories, industries, languages, largeThumbnail, banner, screenshots, listed, ownerFolder, size, 
    // the Hub API doesn't currently return protected
    protected: isProtected, commentsEnabled, 
    // the Hub API doesn't currently return numComments, numRatings,
    // avgRating, numViews, itemControl, scoreCompleteness
    numComments, numRatings, avgRating, numViews, itemControl, scoreCompleteness, 
    // additional attributes we'll need
    // to derive the above values when missing
    itemExtent, itemModified, modifiedProvenance, serviceSpatialReference, } = attributes;
    // layer datasets will get their type from the layer
    // so we will need to derive the item type from the URL
    const serviceType = url && urls_1.getServiceTypeFromUrl(url);
    // build and return an item from properties
    // NOTE: we currently do NOT provide default values
    // (i.e. null for scalar attributes, [] for arrays, etc)
    // for attributes that are not returned by the Hub API
    // this helps distinguish an item that comes from the API
    // but forces all consumers to do handle missing properties
    return {
        id: itemId,
        owner: owner,
        orgId,
        created: created,
        // for feature layers, modified will usually come from the layer so
        // we prefer itemModified, but fall back to modified if it came from the item
        modified: (itemModified ||
            (modifiedProvenance === "item.modified" && modified)),
        title: (title || name),
        type: serviceType || type,
        typeKeywords,
        description,
        tags,
        snippet,
        thumbnail,
        extent: itemExtent ||
            /* istanbul ignore next: API should always return itemExtent, but we default to [] just in case */ [],
        categories,
        contentStatus,
        spatialReference: spatialReference || serviceSpatialReference,
        accessInformation,
        licenseInfo,
        culture,
        url,
        access,
        size,
        protected: isProtected,
        proxyFilter,
        properties,
        appCategories,
        industries,
        languages,
        largeThumbnail,
        banner,
        screenshots,
        listed,
        ownerFolder,
        commentsEnabled,
        numComments,
        numRatings,
        avgRating,
        numViews,
        itemControl,
        scoreCompleteness,
    };
}
exports.datasetToItem = datasetToItem;
/**
 * returns a new content that has the specified type and
 * and updated related properties like, family, etc
 * @param content orignal content
 * @param type new type
 * @returns new content
 */
exports.setContentType = (content, type) => {
    // get family and normalized type based on new type
    const normalizedType = compose_1.normalizeItemType(Object.assign(Object.assign({}, content.item), { type }));
    const family = get_family_1.getFamily(normalizedType);
    const contentTypeIcon = compose_1.getContentTypeIcon(normalizedType);
    const contentTypeLabel = exports.getContentTypeLabel(normalizedType, content.isProxied);
    const updated = Object.assign(Object.assign({}, content), { type: normalizedType, family,
        contentTypeIcon,
        contentTypeLabel });
    // update the relative URL to the content
    // which is based on type and family
    return appendContentUrls(updated, {
        relative: getContentRelativeUrl(updated),
    });
};
/**
 * Compute the content type label
 * @param contentType
 * @param isProxied
 * @returns content type label
 */
exports.getContentTypeLabel = (contentType, isProxied) => {
    return isProxied ? "CSV" : util_1.camelize(contentType || "");
};
// URL helpers
const appendContentUrls = (content, newUrls) => {
    // merge new urls into existing ones and return a new content
    const urls = Object.assign(Object.assign({}, content.urls), newUrls);
    return Object.assign(Object.assign({}, content), { urls });
};
const getContentRelativeUrl = (content, siteIdentifier) => {
    return _internal_1.getHubRelativeUrl(content.type, siteIdentifier || content.identifier, content.typeKeywords);
};
//# sourceMappingURL=index.js.map